!SESSION 2023-02-20 22:07:32.092 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=aarch64, WS=cocoa, NL=en_GB
Framework arguments:  -product org.eclipse.epp.package.jee.product -keyring /Users/neilurquhart/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch aarch64 -product org.eclipse.epp.package.jee.product -keyring /Users/neilurquhart/.eclipse_keyring

This is a continuation of log file /Users/neilurquhart/Dropbox/LB-CPC/.metadata/.bak_0.log
Created Time: 2023-02-20 23:02:27.312

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-02-20 23:02:27.312
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-02-20 23:02:27.312
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-20 23:03:15.975
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Random;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Individual {
	private Random rnd = new Random();
	private ArrayList<Gene> chromosome;
	private ArrayList<TrainingSlot> free;
	private boolean modified = true;
	private int fitness;
	private int expired=0;
	private int lates=0;
	private int groupImbalanced=0;
	private int lowConstraintViolations=0;
	private int mediumConstraintViolations=0;
	private int highConstraintViolations=0;

	private int[][][]participants = new int[ProblemParameters.WEEKS][][];
	private static ArrayList<CustomConstraint> customConstraints;


	private static int[] targets=null;//Targets from each group

	//	public static void loadConstraints() {
	//		//		constraintsPresent = new ArrayList<String>();
	//		//		constraintsNotPresent = new ArrayList<String>();
	//		customConstraints = new ArrayList<CustomConstraint>();
	//		String fileName = "./constraints.txt";
	//
	//
	//		try (BufferedReader br = new BufferedReader(new FileReader(fileName))) {
	//			String line;
	//			int lineNo=1;
	//			while ((line = br.readLine()) != null) {
	//				//process line
	//				CustomConstraint cp=null;
	//				try {
	//					cp = Parser.parse(line);
	//
	//				}catch(Exception e) {
	//					System.out.println("Error reading constraints \nLine no " + lineNo +" "+ e.getMessage());
	//					System.exit(-1);
	//				}
	//				if (cp != null) {
	//					customConstraints.add(cp);
	//					//					char ch = line.charAt(0);
	//					//					line = line.substring(1);
	//					//					if (ch=='+') {
	//					//						constraintsPresent.add(line);
	//					//					}
	//					//					if (ch=='-') {
	//					//						constraintsNotPresent.add(line);
	//					//					}
	//				}
	//				lineNo++;
	//
	//			}
	//		} catch (FileNotFoundException e) {
	//			e.printStackTrace();
	//		} catch (IOException e) {
	//			e.printStackTrace();
	//		}
	//
	//	}
	public static void setConstraints(ArrayList<String> text) {
		//		constraintsPresent = new ArrayList<String>();
		//		constraintsNotPresent = new ArrayList<String>();
		customConstraints = new ArrayList<CustomConstraint>();


		int lineNo=1;
		for (String line : text) {
			//process line
			CustomConstraint cp=null;
			try {
				cp = Parser.parse(line);

			}catch(Exception e) {
				System.out.println("Error reading constraints \nLine no " + lineNo +" "+ e.getMessage());
				System.exit(-1);
			}
			if (cp != null) {
				customConstraints.add(cp);
			}
			lineNo++;
		}
	}
	public Individual() {
		init();
		if (targets==null) {
			int tDrivers = DriverFactory.getDriverList().size();
			targets = new int[Group.values().length];
			for(Group g :Group.values()) {
				int count=0;
				for (Driver d : DriverFactory.getDriverList()) {
					if (d.group()==g)					
						count++;
				}
				float t =  (count/(float)tDrivers)*ProblemParameters.TRAINING_PLACES;
				targets[g.ordinal()] = Math.round(t);
				targets[g.ordinal()]++;
				//				System.out.println("Target " + g.name() + " "+targets[g.ordinal()]);
			}

		}

	}
	public int fitness() {
		//		try {
		//			this.verify();
		//		} catch (Exception e) {
		//			// TODO Auto-generated catch block
		//			e.printStackTrace();
		//			System.exit(-1);
		//		}

		if (modified) {
			ProblemParameters.EVALS++;
			modified = false;
			fitness =0;
			lates=0;
			expired=0;
			groupImbalanced=0;
			lowConstraintViolations=0;
			mediumConstraintViolations=0;
			highConstraintViolations=0;
			//Count participants from each group.
			for (int x=0;x < participants.length; x++ ) {
				for (int d=0; d < 7; d++) {
					for (int g =0; g < Group.values().length; g++ )
						participants[x][d][g] = 0;
				}
			}


			for (Gene g : chromosome) {
				
				if (checkLate(g)) {
					fitness = fitness + ProblemParameters.PENALTY_LATE_SHIFT;
					lates++;
				}
				//Check for training after expiry
				if (checkExpiry(g)) {
					fitness = fitness + ProblemParameters.PENALTY_EXPIRED_LICENSE;
					expired++;
				}else {
				//Encourage training as far before expiry as possible
					(g.slot.getWeek()/g.driver.getExpiresWeek())*ProblemParameters.
				}
				//Log participation
				participants[g.slot.getWeek()][g.slot.getDay()][g.driver.group().ordinal()]++;

			}
			//Check for imbalance in participants
			checkImbalance();
			checkCustomConstraints();
		}
		return fitness;
	}
	
	private void checkCustomConstraints(Gene g, String intermediate) {
		for (CustomConstraint cp : customConstraints) {
			if (!cp.mustAppear()) {
				int found = 0;
					//Matcher matcher = pattern.matcher(i);
					Matcher matcher = cp.getPattern().matcher(intermediate);
					if (matcher.find()) {
						found ++;
					}
				

				int p=1;
				if (found > 0)
					System.out.println("\t Violation " + cp.getSource() );
//				if (cp.getPriority() == ConstraintPriority.high) {
//					p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
//					highConstraintViolations  = highConstraintViolations + found;
//				}
//				if (cp.getPriority() == ConstraintPriority.medium) {
//					p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
//					mediumConstraintViolations  = mediumConstraintViolations + found;
//				}
//				if (cp.getPriority() == ConstraintPriority.low) {
//					p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
//					lowConstraintViolations  = lowConstraintViolations + found;
//				}


			}else {
				boolean found = false;
					Matcher matcher = cp.getPattern().matcher(intermediate);
					if (matcher.find()) {
						found = true;
						break;
					}
				
				if (!found) {
					int p=1;
					System.out.println("\t Violation " + cp.getSource() );
//					if (cp.getPriority() == ConstraintPriority.high) {
//						p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
//						highConstraintViolations ++;
//					}
//					if (cp.getPriority() == ConstraintPriority.medium) {
//						p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
//						mediumConstraintViolations ++;
//					}
//					if (cp.getPriority() == ConstraintPriority.low) {
//						p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
//						lowConstraintViolations ++;
//					}

				}
			}
		}
	}
	private void checkCustomConstraints() {
		String[] intermediate = this.getIntermediate();
		for (CustomConstraint cp : customConstraints) {
			if (!cp.mustAppear()) {
				int found = 0;
				for (String i : intermediate) {
					//Matcher matcher = pattern.matcher(i);
					Matcher matcher = cp.getPattern().matcher(i);
					if (matcher.find()) {
						found ++;
					}
				}

				int p=1;
				if (cp.getPriority() == ConstraintPriority.high) {
					p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
					highConstraintViolations  = highConstraintViolations + found;
				}
				if (cp.getPriority() == ConstraintPriority.medium) {
					p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
					mediumConstraintViolations  = mediumConstraintViolations + found;
				}
				if (cp.getPriority() == ConstraintPriority.low) {
					p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
					lowConstraintViolations  = lowConstraintViolations + found;
				}

				fitness = fitness + (found *p);

			}else {
				boolean found = false;
				for (String i : intermediate) {
					Matcher matcher = cp.getPattern().matcher(i);
					if (matcher.find()) {
						found = true;
						break;
					}
				}
				if (!found) {
					int p=1;
					if (cp.getPriority() == ConstraintPriority.high) {
						p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
						highConstraintViolations ++;
					}
					if (cp.getPriority() == ConstraintPriority.medium) {
						p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
						mediumConstraintViolations ++;
					}
					if (cp.getPriority() == ConstraintPriority.low) {
						p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
						lowConstraintViolations ++;
					}

					fitness = fitness + p;
				}
			}
		}
	}
	private void checkImbalance() {
		for (int[][] p : participants) {
			for (int d=0; d < 7; d++) {
				for (Group g : Group.values()) {
					if (p[d][g.ordinal()]>targets[g.ordinal()]) {
						int over = p[d][g.ordinal()]-targets[g.ordinal()];
						groupImbalanced=groupImbalanced+over;
						fitness = fitness +(over *ProblemParameters.PENALTY_GROUP_IMBALANCE);
					}
				}
			}
		}
	}

	private boolean checkLate(Gene g) {
		if (g.driver.getDuty(g.slot.getWeek())==1) {
			return true;
		}
		return false;
	}

	public boolean checkExpiry(Gene g) {
		int week = g.slot.getWeek();
		if (g.driver.finalYear()) {
			if(week >  g.driver.getExpiresWeek()) {
				return true;
			}
		}
		return false;

	}

	public void initParticipants() {
		participants = new int[ProblemParameters.WEEKS][][];
		for (int x=0;x < participants.length; x++ ) {
			participants[x] = new int[7][];
			for (int d=0; d < 7; d++) {
				participants[x][d] = new int[Group.values().length];
			}
		}

	}
	public void init() {

		modified = true;
		initParticipants();
		//Random init
		free = new ArrayList<TrainingSlot>();
		chromosome = new ArrayList<Gene>();

		try {
			free.addAll(SlotFactory.getSlotSet() ) ;

			//Now create genes
			for (Driver d : DriverFactory.getDriverList()) {
				Gene g = new Gene();
				g.driver = d;
				g.slot = getRndUnalloc(d);
				chromosome.add(g);
			}

		} catch (Exception e) {
			e.printStackTrace();
		}
		intermediateBuffer = new String[chromosome.size()];
	}

	private TrainingSlot getRndUnalloc(Driver d) {
		//Bias towards early shift & unexpired

		int idx = rnd.nextInt(free.size());

		for (int tries =0; tries <=150; tries++) {
			TrainingSlot s = free.get(idx);
			int week = s.getWeek();
			if (d.finalYear()) {
				if (week <= d.getExpiresWeek())
					break;
			}else {

				int duty = d.getDuty(week);
				if (duty==2) {
					break;
				}
			}
			idx = rnd.nextInt(free.size());
		}
		return free.remove(idx);
	}

	public void mutate() {
		modified = true;
		//mutate
		if (rnd.nextBoolean()) {
			//Sawp
			Gene g1 = chromosome.get(rnd.nextInt(chromosome.size()));


			//Bias towards slot issues
			if (rnd.nextBoolean()) {
				int t=0;
				while ((g1.driver.getDuty(g1.slot.getWeek())==1) &&( t <11)){
					g1 = chromosome.get(rnd.nextInt(chromosome.size()));
					t++;
				}
			}

			Gene g2 = chromosome.get(rnd.nextInt(chromosome.size()));
			TrainingSlot tmp = g1.slot;
			g1.slot = g2.slot;
			g2.slot = tmp;
		}else {
			//Swap to unalloc
			Gene g1 = chromosome.get(rnd.nextInt(chromosome.size()));
			TrainingSlot tmp = free.remove(rnd.nextInt(free.size()));
			free.add(g1.slot);
			g1.slot = tmp;
		}
	}



	public Individual(Individual p1, Individual p2) throws Exception {
		initParticipants();
		modified = true;
		//Crossover constructor
		free = new ArrayList<TrainingSlot>();
		free.addAll(SlotFactory.getSlotSet()) ;
		chromosome = new ArrayList<Gene>();

		for (int count =0; count <  p1.chromosome.size(); count ++) {
			Gene g  = new Gene();
			Gene p1g = p1.chromosome.get(count);
			Gene p2g = p2.chromosome.get(count);
			g.driver = p1g.driver;
			if (rnd.nextBoolean()) {
				//Add p1
				TrainingSlot s = p1g.slot;
				if (free.contains(s)) {
					g.slot = s;
					free.remove(s);
				}else {
					s = p2g.slot;
					if (free.contains(s)) {
						g.slot = s;
						free.remove(s);
					}else {
						s = free.remove(0);
						g.slot=s;
					}
				}
			}else{
				//Add p2
				TrainingSlot s = p2g.slot;
				if (free.contains(s)) {
					g.slot = s;
					free.remove(s);
				}else {
					s = p1g.slot;
					if (free.contains(s)) {
						g.slot = s;
						free.remove(s);
					}else {
						s = free.remove(0);
						g.slot=s;
					}
				}
			}
			chromosome.add(g);
		}
		intermediateBuffer = new String[chromosome.size()];
	}

	public void printSummary() {
		if (modified) {
			this.fitness();
		};
		//...
		System.out.println("CPC Plan");
		System.out.println("Issues :");
		System.out.println("CPC on lates shift: \t" +lates); 
		System.out.println("License expired before training: \t"+expired);
		System.out.println("Imbalanced group places: \t"+groupImbalanced);
		System.out.println("Low Constraint violations: \t"+lowConstraintViolations);
		System.out.println("Medium Constraint violations: \t"+mediumConstraintViolations);
		System.out.println("High Constraint violations: \t"+highConstraintViolations);

	}

	public String findIntermediate(String[] intermediate, Gene g) {
		String drvId = g.driver.getID();
		for (String s : intermediate) {
			if (s.contains(drvId))
				return s;
		}
		return null;
	}
	public void printSol() {
		
		String[] intermediate = this.getIntermediate();
		
		System.out.println("Plan by week / day ");
		System.out.println("Week , Day , Driver ID ,Group,Duty,Expiry Week, Final Year" );
		//Print by week
		for (int week =0; week < ProblemParameters.WEEKS; week++) {
			for (int day =0; day < 7; day ++) {
				for (Gene g : chromosome) {
					if ((g.slot.getWeek() == week) && (g.slot.getDay()==day)) {

						System.out.print(week + "," +day +"," + g.driver.getID() +"," +g.driver.group().name() + "," +g.driver.getDuty(week)+","+g.driver.getExpiresWeek() + ","+g.driver.finalYear() );
						if (this.checkExpiry(g))
								System.out.print("\tLICENSE EXPIRED!");

						if (this.checkLate(g))
							System.out.print("\tON LATE DUTY!");
						
						System.out.println();
						String inter = findIntermediate(intermediate,g);
						
						//Now check custom constraints
						this.checkCustomConstraints(g, inter);
						
//						System.out.println("\t"+inter);
					}
				}
			}
		}

		
		
//		System.out.println("Plan by week / day ");
//		System.out.println("Week , Day , Driver ID ,Group,Duty,Expiry Week, Final Year" );
//		//Print by week
//		for (int week =0; week < ProblemParameters.WEEKS; week++) {
//			for (int day =0; day < 7; day ++) {
//				for (Gene g : chromosome) {
//					if ((g.slot.getWeek() == week) && (g.slot.getDay()==day)) {
//
//						System.out.print(week + "," +day +"," + g.driver.getID() +"," +g.driver.group().name() + "," +g.driver.getDuty(week)+","+g.driver.getExpiresWeek() + ","+g.driver.finalYear() );
//						if (g.driver.finalYear())
//							if(g.driver.getExpiresWeek() < week)
//								System.out.print(", LICENSE EXPIRED!");
//
//						if (g.driver.getDuty(week)==1)
//							System.out.print(", ON LATE DUTY!");
//						System.out.println();
//					}
//				}
//			}
//		}
//
//		System.out.println("Additional constraints:");
//		String[] intermediate = this.getIntermediate();
//
//		for (CustomConstraint cp: customConstraints) {
//			//Pattern pattern = Pattern.compile(cp.getRegex(), Pattern.CASE_INSENSITIVE);
//			System.out.print("'"+cp.getSource());
//			if (cp.mustAppear()) {
//				boolean found = false;
//				for (String i : intermediate) {
//					Matcher matcher = cp.getPattern().matcher(i);
//					if (matcher.find()) 
//						found = true;
//				}
//				if (found) 
//					System.out.println( "' has been met." );
//				else
//					System.out.println( "' has not been met." );
//			}else {
//				boolean found = false;
//				for (String i : intermediate) {
//					Matcher matcher = cp.getPattern().matcher(i);
//					if (matcher.find()) 
//						found = true;
//				}
//
//				if (!found) 
//					System.out.println("' has been met." );
//				else
//					System.out.println("' has not been met." );
//
//				
//			}
//
//		}
	}

	private String[] intermediateBuffer;

	public String[] getIntermediate() {
		//Print by week
		int c=0;
		for (Gene g : chromosome) {
			String w =""+ g.slot.getWeek();
			if (w.length()<2) w ="0"+w;

			String xw = ""+g.driver.getExpiresWeek();
			if (xw.length()<2) xw ="0"+xw;
			int fy=0;
			if (g.driver.finalYear()) fy=1;

			//intermediateBuffer[c] =  (":WK:"+w + ":DY:" +g.slot.getDay() +":ID:" + g.driver.getID() +":GR:" +g.driver.group().name() + ":DT:" +g.driver.getDuty(g.slot.getWeek())+":XW:"+xw + ":FY:"+fy );	
			intermediateBuffer[c] =  (
					":ID:" + g.driver.getID() +
					":GR:" +g.driver.group().name() + 
					":WK:"+w + 
					":DY:" +g.slot.getDay() +
					":DT:" +g.driver.getDuty(g.slot.getWeek())+
					":XW:"+xw + 
					":FY:"+fy );	

			c++;
		}
		//		String buffer = "";
		//		for (String s : intermediateBuffer) {
		//			//			buffer = buffer + s;
		//		}
		return intermediateBuffer;
	}


	public Individual (Individual other) {
		initParticipants();
		//Copy constructor
		this.chromosome = new ArrayList<Gene>();
		for (Gene og : other.chromosome) {
			Gene ng = new Gene();
			ng.driver = og.driver;
			ng.slot = og.slot;
			this.chromosome.add(ng);
		}

		this.free = new ArrayList<TrainingSlot>();
		for (TrainingSlot s : other.free)
			this.free.add(s);

		modified = true;
		intermediateBuffer = new String[chromosome.size()];
	}

	private void verify() throws Exception {
		/* Verify that the chromsome contains a valid solution */
		ArrayList<TrainingSlot> slots = SlotFactory.getSlotSet();


		for (Gene g : chromosome) {
			if (g.driver == null)
				throw new Exception("Null driver in gene");

			if (g.slot == null)
				throw new Exception("Null slot in gene");


			if (slots.contains(g.slot)) {
				slots.remove(slots.indexOf(g.slot));
			}else {
				throw new Exception("Duplicated slot ");
			}
		}

		for (TrainingSlot s : free) {
			if (slots.contains(s)) {
				slots.remove(slots.indexOf(s));
			}else {
				throw new Exception("Duplicate unallocated slot");
			}
		}
		if (slots.size() !=0) {
			throw new Exception("Extra slots left");
		}
	}
	public String stats() {
		return  "fit," +fitness +",lates,"+lates +",expired,"+expired +",imbalance,"+groupImbalanced +",low," +lowConstraintViolations +",med," +mediumConstraintViolations+",high," +highConstraintViolations;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-02-20 23:03:15.976
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-02-20 23:03:15.976
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-20 23:03:15.988
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Random;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Individual {
	private Random rnd = new Random();
	private ArrayList<Gene> chromosome;
	private ArrayList<TrainingSlot> free;
	private boolean modified = true;
	private int fitness;
	private int expired=0;
	private int lates=0;
	private int groupImbalanced=0;
	private int lowConstraintViolations=0;
	private int mediumConstraintViolations=0;
	private int highConstraintViolations=0;

	private int[][][]participants = new int[ProblemParameters.WEEKS][][];
	private static ArrayList<CustomConstraint> customConstraints;


	private static int[] targets=null;//Targets from each group

	//	public static void loadConstraints() {
	//		//		constraintsPresent = new ArrayList<String>();
	//		//		constraintsNotPresent = new ArrayList<String>();
	//		customConstraints = new ArrayList<CustomConstraint>();
	//		String fileName = "./constraints.txt";
	//
	//
	//		try (BufferedReader br = new BufferedReader(new FileReader(fileName))) {
	//			String line;
	//			int lineNo=1;
	//			while ((line = br.readLine()) != null) {
	//				//process line
	//				CustomConstraint cp=null;
	//				try {
	//					cp = Parser.parse(line);
	//
	//				}catch(Exception e) {
	//					System.out.println("Error reading constraints \nLine no " + lineNo +" "+ e.getMessage());
	//					System.exit(-1);
	//				}
	//				if (cp != null) {
	//					customConstraints.add(cp);
	//					//					char ch = line.charAt(0);
	//					//					line = line.substring(1);
	//					//					if (ch=='+') {
	//					//						constraintsPresent.add(line);
	//					//					}
	//					//					if (ch=='-') {
	//					//						constraintsNotPresent.add(line);
	//					//					}
	//				}
	//				lineNo++;
	//
	//			}
	//		} catch (FileNotFoundException e) {
	//			e.printStackTrace();
	//		} catch (IOException e) {
	//			e.printStackTrace();
	//		}
	//
	//	}
	public static void setConstraints(ArrayList<String> text) {
		//		constraintsPresent = new ArrayList<String>();
		//		constraintsNotPresent = new ArrayList<String>();
		customConstraints = new ArrayList<CustomConstraint>();


		int lineNo=1;
		for (String line : text) {
			//process line
			CustomConstraint cp=null;
			try {
				cp = Parser.parse(line);

			}catch(Exception e) {
				System.out.println("Error reading constraints \nLine no " + lineNo +" "+ e.getMessage());
				System.exit(-1);
			}
			if (cp != null) {
				customConstraints.add(cp);
			}
			lineNo++;
		}
	}
	public Individual() {
		init();
		if (targets==null) {
			int tDrivers = DriverFactory.getDriverList().size();
			targets = new int[Group.values().length];
			for(Group g :Group.values()) {
				int count=0;
				for (Driver d : DriverFactory.getDriverList()) {
					if (d.group()==g)					
						count++;
				}
				float t =  (count/(float)tDrivers)*ProblemParameters.TRAINING_PLACES;
				targets[g.ordinal()] = Math.round(t);
				targets[g.ordinal()]++;
				//				System.out.println("Target " + g.name() + " "+targets[g.ordinal()]);
			}

		}

	}
	public int fitness() {
		//		try {
		//			this.verify();
		//		} catch (Exception e) {
		//			// TODO Auto-generated catch block
		//			e.printStackTrace();
		//			System.exit(-1);
		//		}

		if (modified) {
			ProblemParameters.EVALS++;
			modified = false;
			fitness =0;
			lates=0;
			expired=0;
			groupImbalanced=0;
			lowConstraintViolations=0;
			mediumConstraintViolations=0;
			highConstraintViolations=0;
			//Count participants from each group.
			for (int x=0;x < participants.length; x++ ) {
				for (int d=0; d < 7; d++) {
					for (int g =0; g < Group.values().length; g++ )
						participants[x][d][g] = 0;
				}
			}


			for (Gene g : chromosome) {
				
				if (checkLate(g)) {
					fitness = fitness + ProblemParameters.PENALTY_LATE_SHIFT;
					lates++;
				}
				//Check for training after expiry
				if (checkExpiry(g)) {
					fitness = fitness + ProblemParameters.PENALTY_EXPIRED_LICENSE;
					expired++;
				}else {
				//Encourage training as far before expiry as possible
					(g.slot.getWeek()/g.driver.getExpiresWeek())*ProblemParameters.
				}
				//Log participation
				participants[g.slot.getWeek()][g.slot.getDay()][g.driver.group().ordinal()]++;

			}
			//Check for imbalance in participants
			checkImbalance();
			checkCustomConstraints();
		}
		return fitness;
	}
	
	private void checkCustomConstraints(Gene g, String intermediate) {
		for (CustomConstraint cp : customConstraints) {
			if (!cp.mustAppear()) {
				int found = 0;
					//Matcher matcher = pattern.matcher(i);
					Matcher matcher = cp.getPattern().matcher(intermediate);
					if (matcher.find()) {
						found ++;
					}
				

				int p=1;
				if (found > 0)
					System.out.println("\t Violation " + cp.getSource() );
//				if (cp.getPriority() == ConstraintPriority.high) {
//					p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
//					highConstraintViolations  = highConstraintViolations + found;
//				}
//				if (cp.getPriority() == ConstraintPriority.medium) {
//					p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
//					mediumConstraintViolations  = mediumConstraintViolations + found;
//				}
//				if (cp.getPriority() == ConstraintPriority.low) {
//					p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
//					lowConstraintViolations  = lowConstraintViolations + found;
//				}


			}else {
				boolean found = false;
					Matcher matcher = cp.getPattern().matcher(intermediate);
					if (matcher.find()) {
						found = true;
						break;
					}
				
				if (!found) {
					int p=1;
					System.out.println("\t Violation " + cp.getSource() );
//					if (cp.getPriority() == ConstraintPriority.high) {
//						p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
//						highConstraintViolations ++;
//					}
//					if (cp.getPriority() == ConstraintPriority.medium) {
//						p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
//						mediumConstraintViolations ++;
//					}
//					if (cp.getPriority() == ConstraintPriority.low) {
//						p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
//						lowConstraintViolations ++;
//					}

				}
			}
		}
	}
	private void checkCustomConstraints() {
		String[] intermediate = this.getIntermediate();
		for (CustomConstraint cp : customConstraints) {
			if (!cp.mustAppear()) {
				int found = 0;
				for (String i : intermediate) {
					//Matcher matcher = pattern.matcher(i);
					Matcher matcher = cp.getPattern().matcher(i);
					if (matcher.find()) {
						found ++;
					}
				}

				int p=1;
				if (cp.getPriority() == ConstraintPriority.high) {
					p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
					highConstraintViolations  = highConstraintViolations + found;
				}
				if (cp.getPriority() == ConstraintPriority.medium) {
					p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
					mediumConstraintViolations  = mediumConstraintViolations + found;
				}
				if (cp.getPriority() == ConstraintPriority.low) {
					p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
					lowConstraintViolations  = lowConstraintViolations + found;
				}

				fitness = fitness + (found *p);

			}else {
				boolean found = false;
				for (String i : intermediate) {
					Matcher matcher = cp.getPattern().matcher(i);
					if (matcher.find()) {
						found = true;
						break;
					}
				}
				if (!found) {
					int p=1;
					if (cp.getPriority() == ConstraintPriority.high) {
						p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
						highConstraintViolations ++;
					}
					if (cp.getPriority() == ConstraintPriority.medium) {
						p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
						mediumConstraintViolations ++;
					}
					if (cp.getPriority() == ConstraintPriority.low) {
						p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
						lowConstraintViolations ++;
					}

					fitness = fitness + p;
				}
			}
		}
	}
	private void checkImbalance() {
		for (int[][] p : participants) {
			for (int d=0; d < 7; d++) {
				for (Group g : Group.values()) {
					if (p[d][g.ordinal()]>targets[g.ordinal()]) {
						int over = p[d][g.ordinal()]-targets[g.ordinal()];
						groupImbalanced=groupImbalanced+over;
						fitness = fitness +(over *ProblemParameters.PENALTY_GROUP_IMBALANCE);
					}
				}
			}
		}
	}

	private boolean checkLate(Gene g) {
		if (g.driver.getDuty(g.slot.getWeek())==1) {
			return true;
		}
		return false;
	}

	public boolean checkExpiry(Gene g) {
		int week = g.slot.getWeek();
		if (g.driver.finalYear()) {
			if(week >  g.driver.getExpiresWeek()) {
				return true;
			}
		}
		return false;

	}

	public void initParticipants() {
		participants = new int[ProblemParameters.WEEKS][][];
		for (int x=0;x < participants.length; x++ ) {
			participants[x] = new int[7][];
			for (int d=0; d < 7; d++) {
				participants[x][d] = new int[Group.values().length];
			}
		}

	}
	public void init() {

		modified = true;
		initParticipants();
		//Random init
		free = new ArrayList<TrainingSlot>();
		chromosome = new ArrayList<Gene>();

		try {
			free.addAll(SlotFactory.getSlotSet() ) ;

			//Now create genes
			for (Driver d : DriverFactory.getDriverList()) {
				Gene g = new Gene();
				g.driver = d;
				g.slot = getRndUnalloc(d);
				chromosome.add(g);
			}

		} catch (Exception e) {
			e.printStackTrace();
		}
		intermediateBuffer = new String[chromosome.size()];
	}

	private TrainingSlot getRndUnalloc(Driver d) {
		//Bias towards early shift & unexpired

		int idx = rnd.nextInt(free.size());

		for (int tries =0; tries <=150; tries++) {
			TrainingSlot s = free.get(idx);
			int week = s.getWeek();
			if (d.finalYear()) {
				if (week <= d.getExpiresWeek())
					break;
			}else {

				int duty = d.getDuty(week);
				if (duty==2) {
					break;
				}
			}
			idx = rnd.nextInt(free.size());
		}
		return free.remove(idx);
	}

	public void mutate() {
		modified = true;
		//mutate
		if (rnd.nextBoolean()) {
			//Sawp
			Gene g1 = chromosome.get(rnd.nextInt(chromosome.size()));


			//Bias towards slot issues
			if (rnd.nextBoolean()) {
				int t=0;
				while ((g1.driver.getDuty(g1.slot.getWeek())==1) &&( t <11)){
					g1 = chromosome.get(rnd.nextInt(chromosome.size()));
					t++;
				}
			}

			Gene g2 = chromosome.get(rnd.nextInt(chromosome.size()));
			TrainingSlot tmp = g1.slot;
			g1.slot = g2.slot;
			g2.slot = tmp;
		}else {
			//Swap to unalloc
			Gene g1 = chromosome.get(rnd.nextInt(chromosome.size()));
			TrainingSlot tmp = free.remove(rnd.nextInt(free.size()));
			free.add(g1.slot);
			g1.slot = tmp;
		}
	}



	public Individual(Individual p1, Individual p2) throws Exception {
		initParticipants();
		modified = true;
		//Crossover constructor
		free = new ArrayList<TrainingSlot>();
		free.addAll(SlotFactory.getSlotSet()) ;
		chromosome = new ArrayList<Gene>();

		for (int count =0; count <  p1.chromosome.size(); count ++) {
			Gene g  = new Gene();
			Gene p1g = p1.chromosome.get(count);
			Gene p2g = p2.chromosome.get(count);
			g.driver = p1g.driver;
			if (rnd.nextBoolean()) {
				//Add p1
				TrainingSlot s = p1g.slot;
				if (free.contains(s)) {
					g.slot = s;
					free.remove(s);
				}else {
					s = p2g.slot;
					if (free.contains(s)) {
						g.slot = s;
						free.remove(s);
					}else {
						s = free.remove(0);
						g.slot=s;
					}
				}
			}else{
				//Add p2
				TrainingSlot s = p2g.slot;
				if (free.contains(s)) {
					g.slot = s;
					free.remove(s);
				}else {
					s = p1g.slot;
					if (free.contains(s)) {
						g.slot = s;
						free.remove(s);
					}else {
						s = free.remove(0);
						g.slot=s;
					}
				}
			}
			chromosome.add(g);
		}
		intermediateBuffer = new String[chromosome.size()];
	}

	public void printSummary() {
		if (modified) {
			this.fitness();
		};
		//...
		System.out.println("CPC Plan");
		System.out.println("Issues :");
		System.out.println("CPC on lates shift: \t" +lates); 
		System.out.println("License expired before training: \t"+expired);
		System.out.println("Imbalanced group places: \t"+groupImbalanced);
		System.out.println("Low Constraint violations: \t"+lowConstraintViolations);
		System.out.println("Medium Constraint violations: \t"+mediumConstraintViolations);
		System.out.println("High Constraint violations: \t"+highConstraintViolations);

	}

	public String findIntermediate(String[] intermediate, Gene g) {
		String drvId = g.driver.getID();
		for (String s : intermediate) {
			if (s.contains(drvId))
				return s;
		}
		return null;
	}
	public void printSol() {
		
		String[] intermediate = this.getIntermediate();
		
		System.out.println("Plan by week / day ");
		System.out.println("Week , Day , Driver ID ,Group,Duty,Expiry Week, Final Year" );
		//Print by week
		for (int week =0; week < ProblemParameters.WEEKS; week++) {
			for (int day =0; day < 7; day ++) {
				for (Gene g : chromosome) {
					if ((g.slot.getWeek() == week) && (g.slot.getDay()==day)) {

						System.out.print(week + "," +day +"," + g.driver.getID() +"," +g.driver.group().name() + "," +g.driver.getDuty(week)+","+g.driver.getExpiresWeek() + ","+g.driver.finalYear() );
						if (this.checkExpiry(g))
								System.out.print("\tLICENSE EXPIRED!");

						if (this.checkLate(g))
							System.out.print("\tON LATE DUTY!");
						
						System.out.println();
						String inter = findIntermediate(intermediate,g);
						
						//Now check custom constraints
						this.checkCustomConstraints(g, inter);
						
//						System.out.println("\t"+inter);
					}
				}
			}
		}

		
		
//		System.out.println("Plan by week / day ");
//		System.out.println("Week , Day , Driver ID ,Group,Duty,Expiry Week, Final Year" );
//		//Print by week
//		for (int week =0; week < ProblemParameters.WEEKS; week++) {
//			for (int day =0; day < 7; day ++) {
//				for (Gene g : chromosome) {
//					if ((g.slot.getWeek() == week) && (g.slot.getDay()==day)) {
//
//						System.out.print(week + "," +day +"," + g.driver.getID() +"," +g.driver.group().name() + "," +g.driver.getDuty(week)+","+g.driver.getExpiresWeek() + ","+g.driver.finalYear() );
//						if (g.driver.finalYear())
//							if(g.driver.getExpiresWeek() < week)
//								System.out.print(", LICENSE EXPIRED!");
//
//						if (g.driver.getDuty(week)==1)
//							System.out.print(", ON LATE DUTY!");
//						System.out.println();
//					}
//				}
//			}
//		}
//
//		System.out.println("Additional constraints:");
//		String[] intermediate = this.getIntermediate();
//
//		for (CustomConstraint cp: customConstraints) {
//			//Pattern pattern = Pattern.compile(cp.getRegex(), Pattern.CASE_INSENSITIVE);
//			System.out.print("'"+cp.getSource());
//			if (cp.mustAppear()) {
//				boolean found = false;
//				for (String i : intermediate) {
//					Matcher matcher = cp.getPattern().matcher(i);
//					if (matcher.find()) 
//						found = true;
//				}
//				if (found) 
//					System.out.println( "' has been met." );
//				else
//					System.out.println( "' has not been met." );
//			}else {
//				boolean found = false;
//				for (String i : intermediate) {
//					Matcher matcher = cp.getPattern().matcher(i);
//					if (matcher.find()) 
//						found = true;
//				}
//
//				if (!found) 
//					System.out.println("' has been met." );
//				else
//					System.out.println("' has not been met." );
//
//				
//			}
//
//		}
	}

	private String[] intermediateBuffer;

	public String[] getIntermediate() {
		//Print by week
		int c=0;
		for (Gene g : chromosome) {
			String w =""+ g.slot.getWeek();
			if (w.length()<2) w ="0"+w;

			String xw = ""+g.driver.getExpiresWeek();
			if (xw.length()<2) xw ="0"+xw;
			int fy=0;
			if (g.driver.finalYear()) fy=1;

			//intermediateBuffer[c] =  (":WK:"+w + ":DY:" +g.slot.getDay() +":ID:" + g.driver.getID() +":GR:" +g.driver.group().name() + ":DT:" +g.driver.getDuty(g.slot.getWeek())+":XW:"+xw + ":FY:"+fy );	
			intermediateBuffer[c] =  (
					":ID:" + g.driver.getID() +
					":GR:" +g.driver.group().name() + 
					":WK:"+w + 
					":DY:" +g.slot.getDay() +
					":DT:" +g.driver.getDuty(g.slot.getWeek())+
					":XW:"+xw + 
					":FY:"+fy );	

			c++;
		}
		//		String buffer = "";
		//		for (String s : intermediateBuffer) {
		//			//			buffer = buffer + s;
		//		}
		return intermediateBuffer;
	}


	public Individual (Individual other) {
		initParticipants();
		//Copy constructor
		this.chromosome = new ArrayList<Gene>();
		for (Gene og : other.chromosome) {
			Gene ng = new Gene();
			ng.driver = og.driver;
			ng.slot = og.slot;
			this.chromosome.add(ng);
		}

		this.free = new ArrayList<TrainingSlot>();
		for (TrainingSlot s : other.free)
			this.free.add(s);

		modified = true;
		intermediateBuffer = new String[chromosome.size()];
	}

	private void verify() throws Exception {
		/* Verify that the chromsome contains a valid solution */
		ArrayList<TrainingSlot> slots = SlotFactory.getSlotSet();


		for (Gene g : chromosome) {
			if (g.driver == null)
				throw new Exception("Null driver in gene");

			if (g.slot == null)
				throw new Exception("Null slot in gene");


			if (slots.contains(g.slot)) {
				slots.remove(slots.indexOf(g.slot));
			}else {
				throw new Exception("Duplicated slot ");
			}
		}

		for (TrainingSlot s : free) {
			if (slots.contains(s)) {
				slots.remove(slots.indexOf(s));
			}else {
				throw new Exception("Duplicate unallocated slot");
			}
		}
		if (slots.size() !=0) {
			throw new Exception("Extra slots left");
		}
	}
	public String stats() {
		return  "fit," +fitness +",lates,"+lates +",expired,"+expired +",imbalance,"+groupImbalanced +",low," +lowConstraintViolations +",med," +mediumConstraintViolations+",high," +highConstraintViolations;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-02-20 23:03:15.988
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-02-20 23:03:15.989
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-20 23:03:17.939
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Random;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Individual {
	private Random rnd = new Random();
	private ArrayList<Gene> chromosome;
	private ArrayList<TrainingSlot> free;
	private boolean modified = true;
	private int fitness;
	private int expired=0;
	private int lates=0;
	private int groupImbalanced=0;
	private int lowConstraintViolations=0;
	private int mediumConstraintViolations=0;
	private int highConstraintViolations=0;

	private int[][][]participants = new int[ProblemParameters.WEEKS][][];
	private static ArrayList<CustomConstraint> customConstraints;


	private static int[] targets=null;//Targets from each group

	//	public static void loadConstraints() {
	//		//		constraintsPresent = new ArrayList<String>();
	//		//		constraintsNotPresent = new ArrayList<String>();
	//		customConstraints = new ArrayList<CustomConstraint>();
	//		String fileName = "./constraints.txt";
	//
	//
	//		try (BufferedReader br = new BufferedReader(new FileReader(fileName))) {
	//			String line;
	//			int lineNo=1;
	//			while ((line = br.readLine()) != null) {
	//				//process line
	//				CustomConstraint cp=null;
	//				try {
	//					cp = Parser.parse(line);
	//
	//				}catch(Exception e) {
	//					System.out.println("Error reading constraints \nLine no " + lineNo +" "+ e.getMessage());
	//					System.exit(-1);
	//				}
	//				if (cp != null) {
	//					customConstraints.add(cp);
	//					//					char ch = line.charAt(0);
	//					//					line = line.substring(1);
	//					//					if (ch=='+') {
	//					//						constraintsPresent.add(line);
	//					//					}
	//					//					if (ch=='-') {
	//					//						constraintsNotPresent.add(line);
	//					//					}
	//				}
	//				lineNo++;
	//
	//			}
	//		} catch (FileNotFoundException e) {
	//			e.printStackTrace();
	//		} catch (IOException e) {
	//			e.printStackTrace();
	//		}
	//
	//	}
	public static void setConstraints(ArrayList<String> text) {
		//		constraintsPresent = new ArrayList<String>();
		//		constraintsNotPresent = new ArrayList<String>();
		customConstraints = new ArrayList<CustomConstraint>();


		int lineNo=1;
		for (String line : text) {
			//process line
			CustomConstraint cp=null;
			try {
				cp = Parser.parse(line);

			}catch(Exception e) {
				System.out.println("Error reading constraints \nLine no " + lineNo +" "+ e.getMessage());
				System.exit(-1);
			}
			if (cp != null) {
				customConstraints.add(cp);
			}
			lineNo++;
		}
	}
	public Individual() {
		init();
		if (targets==null) {
			int tDrivers = DriverFactory.getDriverList().size();
			targets = new int[Group.values().length];
			for(Group g :Group.values()) {
				int count=0;
				for (Driver d : DriverFactory.getDriverList()) {
					if (d.group()==g)					
						count++;
				}
				float t =  (count/(float)tDrivers)*ProblemParameters.TRAINING_PLACES;
				targets[g.ordinal()] = Math.round(t);
				targets[g.ordinal()]++;
				//				System.out.println("Target " + g.name() + " "+targets[g.ordinal()]);
			}

		}

	}
	public int fitness() {
		//		try {
		//			this.verify();
		//		} catch (Exception e) {
		//			// TODO Auto-generated catch block
		//			e.printStackTrace();
		//			System.exit(-1);
		//		}

		if (modified) {
			ProblemParameters.EVALS++;
			modified = false;
			fitness =0;
			lates=0;
			expired=0;
			groupImbalanced=0;
			lowConstraintViolations=0;
			mediumConstraintViolations=0;
			highConstraintViolations=0;
			//Count participants from each group.
			for (int x=0;x < participants.length; x++ ) {
				for (int d=0; d < 7; d++) {
					for (int g =0; g < Group.values().length; g++ )
						participants[x][d][g] = 0;
				}
			}


			for (Gene g : chromosome) {
				
				if (checkLate(g)) {
					fitness = fitness + ProblemParameters.PENALTY_LATE_SHIFT;
					lates++;
				}
				//Check for training after expiry
				if (checkExpiry(g)) {
					fitness = fitness + ProblemParameters.PENALTY_EXPIRED_LICENSE;
					expired++;
				}else {
				//Encourage training as far before expiry as possible
					(g.slot.getWeek()/g.driver.getExpiresWeek())*ProblemParameters.
				}
				//Log participation
				participants[g.slot.getWeek()][g.slot.getDay()][g.driver.group().ordinal()]++;

			}
			//Check for imbalance in participants
			checkImbalance();
			checkCustomConstraints();
		}
		return fitness;
	}
	
	private void checkCustomConstraints(Gene g, String intermediate) {
		for (CustomConstraint cp : customConstraints) {
			if (!cp.mustAppear()) {
				int found = 0;
					//Matcher matcher = pattern.matcher(i);
					Matcher matcher = cp.getPattern().matcher(intermediate);
					if (matcher.find()) {
						found ++;
					}
				

				int p=1;
				if (found > 0)
					System.out.println("\t Violation " + cp.getSource() );
//				if (cp.getPriority() == ConstraintPriority.high) {
//					p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
//					highConstraintViolations  = highConstraintViolations + found;
//				}
//				if (cp.getPriority() == ConstraintPriority.medium) {
//					p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
//					mediumConstraintViolations  = mediumConstraintViolations + found;
//				}
//				if (cp.getPriority() == ConstraintPriority.low) {
//					p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
//					lowConstraintViolations  = lowConstraintViolations + found;
//				}


			}else {
				boolean found = false;
					Matcher matcher = cp.getPattern().matcher(intermediate);
					if (matcher.find()) {
						found = true;
						break;
					}
				
				if (!found) {
					int p=1;
					System.out.println("\t Violation " + cp.getSource() );
//					if (cp.getPriority() == ConstraintPriority.high) {
//						p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
//						highConstraintViolations ++;
//					}
//					if (cp.getPriority() == ConstraintPriority.medium) {
//						p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
//						mediumConstraintViolations ++;
//					}
//					if (cp.getPriority() == ConstraintPriority.low) {
//						p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
//						lowConstraintViolations ++;
//					}

				}
			}
		}
	}
	private void checkCustomConstraints() {
		String[] intermediate = this.getIntermediate();
		for (CustomConstraint cp : customConstraints) {
			if (!cp.mustAppear()) {
				int found = 0;
				for (String i : intermediate) {
					//Matcher matcher = pattern.matcher(i);
					Matcher matcher = cp.getPattern().matcher(i);
					if (matcher.find()) {
						found ++;
					}
				}

				int p=1;
				if (cp.getPriority() == ConstraintPriority.high) {
					p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
					highConstraintViolations  = highConstraintViolations + found;
				}
				if (cp.getPriority() == ConstraintPriority.medium) {
					p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
					mediumConstraintViolations  = mediumConstraintViolations + found;
				}
				if (cp.getPriority() == ConstraintPriority.low) {
					p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
					lowConstraintViolations  = lowConstraintViolations + found;
				}

				fitness = fitness + (found *p);

			}else {
				boolean found = false;
				for (String i : intermediate) {
					Matcher matcher = cp.getPattern().matcher(i);
					if (matcher.find()) {
						found = true;
						break;
					}
				}
				if (!found) {
					int p=1;
					if (cp.getPriority() == ConstraintPriority.high) {
						p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
						highConstraintViolations ++;
					}
					if (cp.getPriority() == ConstraintPriority.medium) {
						p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
						mediumConstraintViolations ++;
					}
					if (cp.getPriority() == ConstraintPriority.low) {
						p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
						lowConstraintViolations ++;
					}

					fitness = fitness + p;
				}
			}
		}
	}
	private void checkImbalance() {
		for (int[][] p : participants) {
			for (int d=0; d < 7; d++) {
				for (Group g : Group.values()) {
					if (p[d][g.ordinal()]>targets[g.ordinal()]) {
						int over = p[d][g.ordinal()]-targets[g.ordinal()];
						groupImbalanced=groupImbalanced+over;
						fitness = fitness +(over *ProblemParameters.PENALTY_GROUP_IMBALANCE);
					}
				}
			}
		}
	}

	private boolean checkLate(Gene g) {
		if (g.driver.getDuty(g.slot.getWeek())==1) {
			return true;
		}
		return false;
	}

	public boolean checkExpiry(Gene g) {
		int week = g.slot.getWeek();
		if (g.driver.finalYear()) {
			if(week >  g.driver.getExpiresWeek()) {
				return true;
			}
		}
		return false;

	}

	public void initParticipants() {
		participants = new int[ProblemParameters.WEEKS][][];
		for (int x=0;x < participants.length; x++ ) {
			participants[x] = new int[7][];
			for (int d=0; d < 7; d++) {
				participants[x][d] = new int[Group.values().length];
			}
		}

	}
	public void init() {

		modified = true;
		initParticipants();
		//Random init
		free = new ArrayList<TrainingSlot>();
		chromosome = new ArrayList<Gene>();

		try {
			free.addAll(SlotFactory.getSlotSet() ) ;

			//Now create genes
			for (Driver d : DriverFactory.getDriverList()) {
				Gene g = new Gene();
				g.driver = d;
				g.slot = getRndUnalloc(d);
				chromosome.add(g);
			}

		} catch (Exception e) {
			e.printStackTrace();
		}
		intermediateBuffer = new String[chromosome.size()];
	}

	private TrainingSlot getRndUnalloc(Driver d) {
		//Bias towards early shift & unexpired

		int idx = rnd.nextInt(free.size());

		for (int tries =0; tries <=150; tries++) {
			TrainingSlot s = free.get(idx);
			int week = s.getWeek();
			if (d.finalYear()) {
				if (week <= d.getExpiresWeek())
					break;
			}else {

				int duty = d.getDuty(week);
				if (duty==2) {
					break;
				}
			}
			idx = rnd.nextInt(free.size());
		}
		return free.remove(idx);
	}

	public void mutate() {
		modified = true;
		//mutate
		if (rnd.nextBoolean()) {
			//Sawp
			Gene g1 = chromosome.get(rnd.nextInt(chromosome.size()));


			//Bias towards slot issues
			if (rnd.nextBoolean()) {
				int t=0;
				while ((g1.driver.getDuty(g1.slot.getWeek())==1) &&( t <11)){
					g1 = chromosome.get(rnd.nextInt(chromosome.size()));
					t++;
				}
			}

			Gene g2 = chromosome.get(rnd.nextInt(chromosome.size()));
			TrainingSlot tmp = g1.slot;
			g1.slot = g2.slot;
			g2.slot = tmp;
		}else {
			//Swap to unalloc
			Gene g1 = chromosome.get(rnd.nextInt(chromosome.size()));
			TrainingSlot tmp = free.remove(rnd.nextInt(free.size()));
			free.add(g1.slot);
			g1.slot = tmp;
		}
	}



	public Individual(Individual p1, Individual p2) throws Exception {
		initParticipants();
		modified = true;
		//Crossover constructor
		free = new ArrayList<TrainingSlot>();
		free.addAll(SlotFactory.getSlotSet()) ;
		chromosome = new ArrayList<Gene>();

		for (int count =0; count <  p1.chromosome.size(); count ++) {
			Gene g  = new Gene();
			Gene p1g = p1.chromosome.get(count);
			Gene p2g = p2.chromosome.get(count);
			g.driver = p1g.driver;
			if (rnd.nextBoolean()) {
				//Add p1
				TrainingSlot s = p1g.slot;
				if (free.contains(s)) {
					g.slot = s;
					free.remove(s);
				}else {
					s = p2g.slot;
					if (free.contains(s)) {
						g.slot = s;
						free.remove(s);
					}else {
						s = free.remove(0);
						g.slot=s;
					}
				}
			}else{
				//Add p2
				TrainingSlot s = p2g.slot;
				if (free.contains(s)) {
					g.slot = s;
					free.remove(s);
				}else {
					s = p1g.slot;
					if (free.contains(s)) {
						g.slot = s;
						free.remove(s);
					}else {
						s = free.remove(0);
						g.slot=s;
					}
				}
			}
			chromosome.add(g);
		}
		intermediateBuffer = new String[chromosome.size()];
	}

	public void printSummary() {
		if (modified) {
			this.fitness();
		};
		//...
		System.out.println("CPC Plan");
		System.out.println("Issues :");
		System.out.println("CPC on lates shift: \t" +lates); 
		System.out.println("License expired before training: \t"+expired);
		System.out.println("Imbalanced group places: \t"+groupImbalanced);
		System.out.println("Low Constraint violations: \t"+lowConstraintViolations);
		System.out.println("Medium Constraint violations: \t"+mediumConstraintViolations);
		System.out.println("High Constraint violations: \t"+highConstraintViolations);

	}

	public String findIntermediate(String[] intermediate, Gene g) {
		String drvId = g.driver.getID();
		for (String s : intermediate) {
			if (s.contains(drvId))
				return s;
		}
		return null;
	}
	public void printSol() {
		
		String[] intermediate = this.getIntermediate();
		
		System.out.println("Plan by week / day ");
		System.out.println("Week , Day , Driver ID ,Group,Duty,Expiry Week, Final Year" );
		//Print by week
		for (int week =0; week < ProblemParameters.WEEKS; week++) {
			for (int day =0; day < 7; day ++) {
				for (Gene g : chromosome) {
					if ((g.slot.getWeek() == week) && (g.slot.getDay()==day)) {

						System.out.print(week + "," +day +"," + g.driver.getID() +"," +g.driver.group().name() + "," +g.driver.getDuty(week)+","+g.driver.getExpiresWeek() + ","+g.driver.finalYear() );
						if (this.checkExpiry(g))
								System.out.print("\tLICENSE EXPIRED!");

						if (this.checkLate(g))
							System.out.print("\tON LATE DUTY!");
						
						System.out.println();
						String inter = findIntermediate(intermediate,g);
						
						//Now check custom constraints
						this.checkCustomConstraints(g, inter);
						
//						System.out.println("\t"+inter);
					}
				}
			}
		}

		
		
//		System.out.println("Plan by week / day ");
//		System.out.println("Week , Day , Driver ID ,Group,Duty,Expiry Week, Final Year" );
//		//Print by week
//		for (int week =0; week < ProblemParameters.WEEKS; week++) {
//			for (int day =0; day < 7; day ++) {
//				for (Gene g : chromosome) {
//					if ((g.slot.getWeek() == week) && (g.slot.getDay()==day)) {
//
//						System.out.print(week + "," +day +"," + g.driver.getID() +"," +g.driver.group().name() + "," +g.driver.getDuty(week)+","+g.driver.getExpiresWeek() + ","+g.driver.finalYear() );
//						if (g.driver.finalYear())
//							if(g.driver.getExpiresWeek() < week)
//								System.out.print(", LICENSE EXPIRED!");
//
//						if (g.driver.getDuty(week)==1)
//							System.out.print(", ON LATE DUTY!");
//						System.out.println();
//					}
//				}
//			}
//		}
//
//		System.out.println("Additional constraints:");
//		String[] intermediate = this.getIntermediate();
//
//		for (CustomConstraint cp: customConstraints) {
//			//Pattern pattern = Pattern.compile(cp.getRegex(), Pattern.CASE_INSENSITIVE);
//			System.out.print("'"+cp.getSource());
//			if (cp.mustAppear()) {
//				boolean found = false;
//				for (String i : intermediate) {
//					Matcher matcher = cp.getPattern().matcher(i);
//					if (matcher.find()) 
//						found = true;
//				}
//				if (found) 
//					System.out.println( "' has been met." );
//				else
//					System.out.println( "' has not been met." );
//			}else {
//				boolean found = false;
//				for (String i : intermediate) {
//					Matcher matcher = cp.getPattern().matcher(i);
//					if (matcher.find()) 
//						found = true;
//				}
//
//				if (!found) 
//					System.out.println("' has been met." );
//				else
//					System.out.println("' has not been met." );
//
//				
//			}
//
//		}
	}

	private String[] intermediateBuffer;

	public String[] getIntermediate() {
		//Print by week
		int c=0;
		for (Gene g : chromosome) {
			String w =""+ g.slot.getWeek();
			if (w.length()<2) w ="0"+w;

			String xw = ""+g.driver.getExpiresWeek();
			if (xw.length()<2) xw ="0"+xw;
			int fy=0;
			if (g.driver.finalYear()) fy=1;

			//intermediateBuffer[c] =  (":WK:"+w + ":DY:" +g.slot.getDay() +":ID:" + g.driver.getID() +":GR:" +g.driver.group().name() + ":DT:" +g.driver.getDuty(g.slot.getWeek())+":XW:"+xw + ":FY:"+fy );	
			intermediateBuffer[c] =  (
					":ID:" + g.driver.getID() +
					":GR:" +g.driver.group().name() + 
					":WK:"+w + 
					":DY:" +g.slot.getDay() +
					":DT:" +g.driver.getDuty(g.slot.getWeek())+
					":XW:"+xw + 
					":FY:"+fy );	

			c++;
		}
		//		String buffer = "";
		//		for (String s : intermediateBuffer) {
		//			//			buffer = buffer + s;
		//		}
		return intermediateBuffer;
	}


	public Individual (Individual other) {
		initParticipants();
		//Copy constructor
		this.chromosome = new ArrayList<Gene>();
		for (Gene og : other.chromosome) {
			Gene ng = new Gene();
			ng.driver = og.driver;
			ng.slot = og.slot;
			this.chromosome.add(ng);
		}

		this.free = new ArrayList<TrainingSlot>();
		for (TrainingSlot s : other.free)
			this.free.add(s);

		modified = true;
		intermediateBuffer = new String[chromosome.size()];
	}

	private void verify() throws Exception {
		/* Verify that the chromsome contains a valid solution */
		ArrayList<TrainingSlot> slots = SlotFactory.getSlotSet();


		for (Gene g : chromosome) {
			if (g.driver == null)
				throw new Exception("Null driver in gene");

			if (g.slot == null)
				throw new Exception("Null slot in gene");


			if (slots.contains(g.slot)) {
				slots.remove(slots.indexOf(g.slot));
			}else {
				throw new Exception("Duplicated slot ");
			}
		}

		for (TrainingSlot s : free) {
			if (slots.contains(s)) {
				slots.remove(slots.indexOf(s));
			}else {
				throw new Exception("Duplicate unallocated slot");
			}
		}
		if (slots.size() !=0) {
			throw new Exception("Extra slots left");
		}
	}
	public String stats() {
		return  "fit," +fitness +",lates,"+lates +",expired,"+expired +",imbalance,"+groupImbalanced +",low," +lowConstraintViolations +",med," +mediumConstraintViolations+",high," +highConstraintViolations;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-02-20 23:03:17.940
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-02-20 23:03:17.940
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-20 23:03:18.947
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Random;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Individual {
	private Random rnd = new Random();
	private ArrayList<Gene> chromosome;
	private ArrayList<TrainingSlot> free;
	private boolean modified = true;
	private int fitness;
	private int expired=0;
	private int lates=0;
	private int groupImbalanced=0;
	private int lowConstraintViolations=0;
	private int mediumConstraintViolations=0;
	private int highConstraintViolations=0;

	private int[][][]participants = new int[ProblemParameters.WEEKS][][];
	private static ArrayList<CustomConstraint> customConstraints;


	private static int[] targets=null;//Targets from each group

	//	public static void loadConstraints() {
	//		//		constraintsPresent = new ArrayList<String>();
	//		//		constraintsNotPresent = new ArrayList<String>();
	//		customConstraints = new ArrayList<CustomConstraint>();
	//		String fileName = "./constraints.txt";
	//
	//
	//		try (BufferedReader br = new BufferedReader(new FileReader(fileName))) {
	//			String line;
	//			int lineNo=1;
	//			while ((line = br.readLine()) != null) {
	//				//process line
	//				CustomConstraint cp=null;
	//				try {
	//					cp = Parser.parse(line);
	//
	//				}catch(Exception e) {
	//					System.out.println("Error reading constraints \nLine no " + lineNo +" "+ e.getMessage());
	//					System.exit(-1);
	//				}
	//				if (cp != null) {
	//					customConstraints.add(cp);
	//					//					char ch = line.charAt(0);
	//					//					line = line.substring(1);
	//					//					if (ch=='+') {
	//					//						constraintsPresent.add(line);
	//					//					}
	//					//					if (ch=='-') {
	//					//						constraintsNotPresent.add(line);
	//					//					}
	//				}
	//				lineNo++;
	//
	//			}
	//		} catch (FileNotFoundException e) {
	//			e.printStackTrace();
	//		} catch (IOException e) {
	//			e.printStackTrace();
	//		}
	//
	//	}
	public static void setConstraints(ArrayList<String> text) {
		//		constraintsPresent = new ArrayList<String>();
		//		constraintsNotPresent = new ArrayList<String>();
		customConstraints = new ArrayList<CustomConstraint>();


		int lineNo=1;
		for (String line : text) {
			//process line
			CustomConstraint cp=null;
			try {
				cp = Parser.parse(line);

			}catch(Exception e) {
				System.out.println("Error reading constraints \nLine no " + lineNo +" "+ e.getMessage());
				System.exit(-1);
			}
			if (cp != null) {
				customConstraints.add(cp);
			}
			lineNo++;
		}
	}
	public Individual() {
		init();
		if (targets==null) {
			int tDrivers = DriverFactory.getDriverList().size();
			targets = new int[Group.values().length];
			for(Group g :Group.values()) {
				int count=0;
				for (Driver d : DriverFactory.getDriverList()) {
					if (d.group()==g)					
						count++;
				}
				float t =  (count/(float)tDrivers)*ProblemParameters.TRAINING_PLACES;
				targets[g.ordinal()] = Math.round(t);
				targets[g.ordinal()]++;
				//				System.out.println("Target " + g.name() + " "+targets[g.ordinal()]);
			}

		}

	}
	public int fitness() {
		//		try {
		//			this.verify();
		//		} catch (Exception e) {
		//			// TODO Auto-generated catch block
		//			e.printStackTrace();
		//			System.exit(-1);
		//		}

		if (modified) {
			ProblemParameters.EVALS++;
			modified = false;
			fitness =0;
			lates=0;
			expired=0;
			groupImbalanced=0;
			lowConstraintViolations=0;
			mediumConstraintViolations=0;
			highConstraintViolations=0;
			//Count participants from each group.
			for (int x=0;x < participants.length; x++ ) {
				for (int d=0; d < 7; d++) {
					for (int g =0; g < Group.values().length; g++ )
						participants[x][d][g] = 0;
				}
			}


			for (Gene g : chromosome) {
				
				if (checkLate(g)) {
					fitness = fitness + ProblemParameters.PENALTY_LATE_SHIFT;
					lates++;
				}
				//Check for training after expiry
				if (checkExpiry(g)) {
					fitness = fitness + ProblemParameters.PENALTY_EXPIRED_LICENSE;
					expired++;
				}else {
				//Encourage training as far before expiry as possible
					(g.slot.getWeek()/g.driver.getExpiresWeek())*ProblemParameters.
				}
				//Log participation
				participants[g.slot.getWeek()][g.slot.getDay()][g.driver.group().ordinal()]++;

			}
			//Check for imbalance in participants
			checkImbalance();
			checkCustomConstraints();
		}
		return fitness;
	}
	
	private void checkCustomConstraints(Gene g, String intermediate) {
		for (CustomConstraint cp : customConstraints) {
			if (!cp.mustAppear()) {
				int found = 0;
					//Matcher matcher = pattern.matcher(i);
					Matcher matcher = cp.getPattern().matcher(intermediate);
					if (matcher.find()) {
						found ++;
					}
				

				int p=1;
				if (found > 0)
					System.out.println("\t Violation " + cp.getSource() );
//				if (cp.getPriority() == ConstraintPriority.high) {
//					p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
//					highConstraintViolations  = highConstraintViolations + found;
//				}
//				if (cp.getPriority() == ConstraintPriority.medium) {
//					p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
//					mediumConstraintViolations  = mediumConstraintViolations + found;
//				}
//				if (cp.getPriority() == ConstraintPriority.low) {
//					p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
//					lowConstraintViolations  = lowConstraintViolations + found;
//				}


			}else {
				boolean found = false;
					Matcher matcher = cp.getPattern().matcher(intermediate);
					if (matcher.find()) {
						found = true;
						break;
					}
				
				if (!found) {
					int p=1;
					System.out.println("\t Violation " + cp.getSource() );
//					if (cp.getPriority() == ConstraintPriority.high) {
//						p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
//						highConstraintViolations ++;
//					}
//					if (cp.getPriority() == ConstraintPriority.medium) {
//						p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
//						mediumConstraintViolations ++;
//					}
//					if (cp.getPriority() == ConstraintPriority.low) {
//						p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
//						lowConstraintViolations ++;
//					}

				}
			}
		}
	}
	private void checkCustomConstraints() {
		String[] intermediate = this.getIntermediate();
		for (CustomConstraint cp : customConstraints) {
			if (!cp.mustAppear()) {
				int found = 0;
				for (String i : intermediate) {
					//Matcher matcher = pattern.matcher(i);
					Matcher matcher = cp.getPattern().matcher(i);
					if (matcher.find()) {
						found ++;
					}
				}

				int p=1;
				if (cp.getPriority() == ConstraintPriority.high) {
					p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
					highConstraintViolations  = highConstraintViolations + found;
				}
				if (cp.getPriority() == ConstraintPriority.medium) {
					p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
					mediumConstraintViolations  = mediumConstraintViolations + found;
				}
				if (cp.getPriority() == ConstraintPriority.low) {
					p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
					lowConstraintViolations  = lowConstraintViolations + found;
				}

				fitness = fitness + (found *p);

			}else {
				boolean found = false;
				for (String i : intermediate) {
					Matcher matcher = cp.getPattern().matcher(i);
					if (matcher.find()) {
						found = true;
						break;
					}
				}
				if (!found) {
					int p=1;
					if (cp.getPriority() == ConstraintPriority.high) {
						p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
						highConstraintViolations ++;
					}
					if (cp.getPriority() == ConstraintPriority.medium) {
						p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
						mediumConstraintViolations ++;
					}
					if (cp.getPriority() == ConstraintPriority.low) {
						p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
						lowConstraintViolations ++;
					}

					fitness = fitness + p;
				}
			}
		}
	}
	private void checkImbalance() {
		for (int[][] p : participants) {
			for (int d=0; d < 7; d++) {
				for (Group g : Group.values()) {
					if (p[d][g.ordinal()]>targets[g.ordinal()]) {
						int over = p[d][g.ordinal()]-targets[g.ordinal()];
						groupImbalanced=groupImbalanced+over;
						fitness = fitness +(over *ProblemParameters.PENALTY_GROUP_IMBALANCE);
					}
				}
			}
		}
	}

	private boolean checkLate(Gene g) {
		if (g.driver.getDuty(g.slot.getWeek())==1) {
			return true;
		}
		return false;
	}

	public boolean checkExpiry(Gene g) {
		int week = g.slot.getWeek();
		if (g.driver.finalYear()) {
			if(week >  g.driver.getExpiresWeek()) {
				return true;
			}
		}
		return false;

	}

	public void initParticipants() {
		participants = new int[ProblemParameters.WEEKS][][];
		for (int x=0;x < participants.length; x++ ) {
			participants[x] = new int[7][];
			for (int d=0; d < 7; d++) {
				participants[x][d] = new int[Group.values().length];
			}
		}

	}
	public void init() {

		modified = true;
		initParticipants();
		//Random init
		free = new ArrayList<TrainingSlot>();
		chromosome = new ArrayList<Gene>();

		try {
			free.addAll(SlotFactory.getSlotSet() ) ;

			//Now create genes
			for (Driver d : DriverFactory.getDriverList()) {
				Gene g = new Gene();
				g.driver = d;
				g.slot = getRndUnalloc(d);
				chromosome.add(g);
			}

		} catch (Exception e) {
			e.printStackTrace();
		}
		intermediateBuffer = new String[chromosome.size()];
	}

	private TrainingSlot getRndUnalloc(Driver d) {
		//Bias towards early shift & unexpired

		int idx = rnd.nextInt(free.size());

		for (int tries =0; tries <=150; tries++) {
			TrainingSlot s = free.get(idx);
			int week = s.getWeek();
			if (d.finalYear()) {
				if (week <= d.getExpiresWeek())
					break;
			}else {

				int duty = d.getDuty(week);
				if (duty==2) {
					break;
				}
			}
			idx = rnd.nextInt(free.size());
		}
		return free.remove(idx);
	}

	public void mutate() {
		modified = true;
		//mutate
		if (rnd.nextBoolean()) {
			//Sawp
			Gene g1 = chromosome.get(rnd.nextInt(chromosome.size()));


			//Bias towards slot issues
			if (rnd.nextBoolean()) {
				int t=0;
				while ((g1.driver.getDuty(g1.slot.getWeek())==1) &&( t <11)){
					g1 = chromosome.get(rnd.nextInt(chromosome.size()));
					t++;
				}
			}

			Gene g2 = chromosome.get(rnd.nextInt(chromosome.size()));
			TrainingSlot tmp = g1.slot;
			g1.slot = g2.slot;
			g2.slot = tmp;
		}else {
			//Swap to unalloc
			Gene g1 = chromosome.get(rnd.nextInt(chromosome.size()));
			TrainingSlot tmp = free.remove(rnd.nextInt(free.size()));
			free.add(g1.slot);
			g1.slot = tmp;
		}
	}



	public Individual(Individual p1, Individual p2) throws Exception {
		initParticipants();
		modified = true;
		//Crossover constructor
		free = new ArrayList<TrainingSlot>();
		free.addAll(SlotFactory.getSlotSet()) ;
		chromosome = new ArrayList<Gene>();

		for (int count =0; count <  p1.chromosome.size(); count ++) {
			Gene g  = new Gene();
			Gene p1g = p1.chromosome.get(count);
			Gene p2g = p2.chromosome.get(count);
			g.driver = p1g.driver;
			if (rnd.nextBoolean()) {
				//Add p1
				TrainingSlot s = p1g.slot;
				if (free.contains(s)) {
					g.slot = s;
					free.remove(s);
				}else {
					s = p2g.slot;
					if (free.contains(s)) {
						g.slot = s;
						free.remove(s);
					}else {
						s = free.remove(0);
						g.slot=s;
					}
				}
			}else{
				//Add p2
				TrainingSlot s = p2g.slot;
				if (free.contains(s)) {
					g.slot = s;
					free.remove(s);
				}else {
					s = p1g.slot;
					if (free.contains(s)) {
						g.slot = s;
						free.remove(s);
					}else {
						s = free.remove(0);
						g.slot=s;
					}
				}
			}
			chromosome.add(g);
		}
		intermediateBuffer = new String[chromosome.size()];
	}

	public void printSummary() {
		if (modified) {
			this.fitness();
		};
		//...
		System.out.println("CPC Plan");
		System.out.println("Issues :");
		System.out.println("CPC on lates shift: \t" +lates); 
		System.out.println("License expired before training: \t"+expired);
		System.out.println("Imbalanced group places: \t"+groupImbalanced);
		System.out.println("Low Constraint violations: \t"+lowConstraintViolations);
		System.out.println("Medium Constraint violations: \t"+mediumConstraintViolations);
		System.out.println("High Constraint violations: \t"+highConstraintViolations);

	}

	public String findIntermediate(String[] intermediate, Gene g) {
		String drvId = g.driver.getID();
		for (String s : intermediate) {
			if (s.contains(drvId))
				return s;
		}
		return null;
	}
	public void printSol() {
		
		String[] intermediate = this.getIntermediate();
		
		System.out.println("Plan by week / day ");
		System.out.println("Week , Day , Driver ID ,Group,Duty,Expiry Week, Final Year" );
		//Print by week
		for (int week =0; week < ProblemParameters.WEEKS; week++) {
			for (int day =0; day < 7; day ++) {
				for (Gene g : chromosome) {
					if ((g.slot.getWeek() == week) && (g.slot.getDay()==day)) {

						System.out.print(week + "," +day +"," + g.driver.getID() +"," +g.driver.group().name() + "," +g.driver.getDuty(week)+","+g.driver.getExpiresWeek() + ","+g.driver.finalYear() );
						if (this.checkExpiry(g))
								System.out.print("\tLICENSE EXPIRED!");

						if (this.checkLate(g))
							System.out.print("\tON LATE DUTY!");
						
						System.out.println();
						String inter = findIntermediate(intermediate,g);
						
						//Now check custom constraints
						this.checkCustomConstraints(g, inter);
						
//						System.out.println("\t"+inter);
					}
				}
			}
		}

		
		
//		System.out.println("Plan by week / day ");
//		System.out.println("Week , Day , Driver ID ,Group,Duty,Expiry Week, Final Year" );
//		//Print by week
//		for (int week =0; week < ProblemParameters.WEEKS; week++) {
//			for (int day =0; day < 7; day ++) {
//				for (Gene g : chromosome) {
//					if ((g.slot.getWeek() == week) && (g.slot.getDay()==day)) {
//
//						System.out.print(week + "," +day +"," + g.driver.getID() +"," +g.driver.group().name() + "," +g.driver.getDuty(week)+","+g.driver.getExpiresWeek() + ","+g.driver.finalYear() );
//						if (g.driver.finalYear())
//							if(g.driver.getExpiresWeek() < week)
//								System.out.print(", LICENSE EXPIRED!");
//
//						if (g.driver.getDuty(week)==1)
//							System.out.print(", ON LATE DUTY!");
//						System.out.println();
//					}
//				}
//			}
//		}
//
//		System.out.println("Additional constraints:");
//		String[] intermediate = this.getIntermediate();
//
//		for (CustomConstraint cp: customConstraints) {
//			//Pattern pattern = Pattern.compile(cp.getRegex(), Pattern.CASE_INSENSITIVE);
//			System.out.print("'"+cp.getSource());
//			if (cp.mustAppear()) {
//				boolean found = false;
//				for (String i : intermediate) {
//					Matcher matcher = cp.getPattern().matcher(i);
//					if (matcher.find()) 
//						found = true;
//				}
//				if (found) 
//					System.out.println( "' has been met." );
//				else
//					System.out.println( "' has not been met." );
//			}else {
//				boolean found = false;
//				for (String i : intermediate) {
//					Matcher matcher = cp.getPattern().matcher(i);
//					if (matcher.find()) 
//						found = true;
//				}
//
//				if (!found) 
//					System.out.println("' has been met." );
//				else
//					System.out.println("' has not been met." );
//
//				
//			}
//
//		}
	}

	private String[] intermediateBuffer;

	public String[] getIntermediate() {
		//Print by week
		int c=0;
		for (Gene g : chromosome) {
			String w =""+ g.slot.getWeek();
			if (w.length()<2) w ="0"+w;

			String xw = ""+g.driver.getExpiresWeek();
			if (xw.length()<2) xw ="0"+xw;
			int fy=0;
			if (g.driver.finalYear()) fy=1;

			//intermediateBuffer[c] =  (":WK:"+w + ":DY:" +g.slot.getDay() +":ID:" + g.driver.getID() +":GR:" +g.driver.group().name() + ":DT:" +g.driver.getDuty(g.slot.getWeek())+":XW:"+xw + ":FY:"+fy );	
			intermediateBuffer[c] =  (
					":ID:" + g.driver.getID() +
					":GR:" +g.driver.group().name() + 
					":WK:"+w + 
					":DY:" +g.slot.getDay() +
					":DT:" +g.driver.getDuty(g.slot.getWeek())+
					":XW:"+xw + 
					":FY:"+fy );	

			c++;
		}
		//		String buffer = "";
		//		for (String s : intermediateBuffer) {
		//			//			buffer = buffer + s;
		//		}
		return intermediateBuffer;
	}


	public Individual (Individual other) {
		initParticipants();
		//Copy constructor
		this.chromosome = new ArrayList<Gene>();
		for (Gene og : other.chromosome) {
			Gene ng = new Gene();
			ng.driver = og.driver;
			ng.slot = og.slot;
			this.chromosome.add(ng);
		}

		this.free = new ArrayList<TrainingSlot>();
		for (TrainingSlot s : other.free)
			this.free.add(s);

		modified = true;
		intermediateBuffer = new String[chromosome.size()];
	}

	private void verify() throws Exception {
		/* Verify that the chromsome contains a valid solution */
		ArrayList<TrainingSlot> slots = SlotFactory.getSlotSet();


		for (Gene g : chromosome) {
			if (g.driver == null)
				throw new Exception("Null driver in gene");

			if (g.slot == null)
				throw new Exception("Null slot in gene");


			if (slots.contains(g.slot)) {
				slots.remove(slots.indexOf(g.slot));
			}else {
				throw new Exception("Duplicated slot ");
			}
		}

		for (TrainingSlot s : free) {
			if (slots.contains(s)) {
				slots.remove(slots.indexOf(s));
			}else {
				throw new Exception("Duplicate unallocated slot");
			}
		}
		if (slots.size() !=0) {
			throw new Exception("Extra slots left");
		}
	}
	public String stats() {
		return  "fit," +fitness +",lates,"+lates +",expired,"+expired +",imbalance,"+groupImbalanced +",low," +lowConstraintViolations +",med," +mediumConstraintViolations+",high," +highConstraintViolations;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-02-20 23:03:18.948
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-02-20 23:03:18.948
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-20 23:03:20.427
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Random;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Individual {
	private Random rnd = new Random();
	private ArrayList<Gene> chromosome;
	private ArrayList<TrainingSlot> free;
	private boolean modified = true;
	private int fitness;
	private int expired=0;
	private int lates=0;
	private int groupImbalanced=0;
	private int lowConstraintViolations=0;
	private int mediumConstraintViolations=0;
	private int highConstraintViolations=0;

	private int[][][]participants = new int[ProblemParameters.WEEKS][][];
	private static ArrayList<CustomConstraint> customConstraints;


	private static int[] targets=null;//Targets from each group

	//	public static void loadConstraints() {
	//		//		constraintsPresent = new ArrayList<String>();
	//		//		constraintsNotPresent = new ArrayList<String>();
	//		customConstraints = new ArrayList<CustomConstraint>();
	//		String fileName = "./constraints.txt";
	//
	//
	//		try (BufferedReader br = new BufferedReader(new FileReader(fileName))) {
	//			String line;
	//			int lineNo=1;
	//			while ((line = br.readLine()) != null) {
	//				//process line
	//				CustomConstraint cp=null;
	//				try {
	//					cp = Parser.parse(line);
	//
	//				}catch(Exception e) {
	//					System.out.println("Error reading constraints \nLine no " + lineNo +" "+ e.getMessage());
	//					System.exit(-1);
	//				}
	//				if (cp != null) {
	//					customConstraints.add(cp);
	//					//					char ch = line.charAt(0);
	//					//					line = line.substring(1);
	//					//					if (ch=='+') {
	//					//						constraintsPresent.add(line);
	//					//					}
	//					//					if (ch=='-') {
	//					//						constraintsNotPresent.add(line);
	//					//					}
	//				}
	//				lineNo++;
	//
	//			}
	//		} catch (FileNotFoundException e) {
	//			e.printStackTrace();
	//		} catch (IOException e) {
	//			e.printStackTrace();
	//		}
	//
	//	}
	public static void setConstraints(ArrayList<String> text) {
		//		constraintsPresent = new ArrayList<String>();
		//		constraintsNotPresent = new ArrayList<String>();
		customConstraints = new ArrayList<CustomConstraint>();


		int lineNo=1;
		for (String line : text) {
			//process line
			CustomConstraint cp=null;
			try {
				cp = Parser.parse(line);

			}catch(Exception e) {
				System.out.println("Error reading constraints \nLine no " + lineNo +" "+ e.getMessage());
				System.exit(-1);
			}
			if (cp != null) {
				customConstraints.add(cp);
			}
			lineNo++;
		}
	}
	public Individual() {
		init();
		if (targets==null) {
			int tDrivers = DriverFactory.getDriverList().size();
			targets = new int[Group.values().length];
			for(Group g :Group.values()) {
				int count=0;
				for (Driver d : DriverFactory.getDriverList()) {
					if (d.group()==g)					
						count++;
				}
				float t =  (count/(float)tDrivers)*ProblemParameters.TRAINING_PLACES;
				targets[g.ordinal()] = Math.round(t);
				targets[g.ordinal()]++;
				//				System.out.println("Target " + g.name() + " "+targets[g.ordinal()]);
			}

		}

	}
	public int fitness() {
		//		try {
		//			this.verify();
		//		} catch (Exception e) {
		//			// TODO Auto-generated catch block
		//			e.printStackTrace();
		//			System.exit(-1);
		//		}

		if (modified) {
			ProblemParameters.EVALS++;
			modified = false;
			fitness =0;
			lates=0;
			expired=0;
			groupImbalanced=0;
			lowConstraintViolations=0;
			mediumConstraintViolations=0;
			highConstraintViolations=0;
			//Count participants from each group.
			for (int x=0;x < participants.length; x++ ) {
				for (int d=0; d < 7; d++) {
					for (int g =0; g < Group.values().length; g++ )
						participants[x][d][g] = 0;
				}
			}


			for (Gene g : chromosome) {
				
				if (checkLate(g)) {
					fitness = fitness + ProblemParameters.PENALTY_LATE_SHIFT;
					lates++;
				}
				//Check for training after expiry
				if (checkExpiry(g)) {
					fitness = fitness + ProblemParameters.PENALTY_EXPIRED_LICENSE;
					expired++;
				}else {
				//Encourage training as far before expiry as possible
					(g.slot.getWeek()/g.driver.getExpiresWeek())*ProblemParameters.p
				}
				//Log participation
				participants[g.slot.getWeek()][g.slot.getDay()][g.driver.group().ordinal()]++;

			}
			//Check for imbalance in participants
			checkImbalance();
			checkCustomConstraints();
		}
		return fitness;
	}
	
	private void checkCustomConstraints(Gene g, String intermediate) {
		for (CustomConstraint cp : customConstraints) {
			if (!cp.mustAppear()) {
				int found = 0;
					//Matcher matcher = pattern.matcher(i);
					Matcher matcher = cp.getPattern().matcher(intermediate);
					if (matcher.find()) {
						found ++;
					}
				

				int p=1;
				if (found > 0)
					System.out.println("\t Violation " + cp.getSource() );
//				if (cp.getPriority() == ConstraintPriority.high) {
//					p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
//					highConstraintViolations  = highConstraintViolations + found;
//				}
//				if (cp.getPriority() == ConstraintPriority.medium) {
//					p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
//					mediumConstraintViolations  = mediumConstraintViolations + found;
//				}
//				if (cp.getPriority() == ConstraintPriority.low) {
//					p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
//					lowConstraintViolations  = lowConstraintViolations + found;
//				}


			}else {
				boolean found = false;
					Matcher matcher = cp.getPattern().matcher(intermediate);
					if (matcher.find()) {
						found = true;
						break;
					}
				
				if (!found) {
					int p=1;
					System.out.println("\t Violation " + cp.getSource() );
//					if (cp.getPriority() == ConstraintPriority.high) {
//						p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
//						highConstraintViolations ++;
//					}
//					if (cp.getPriority() == ConstraintPriority.medium) {
//						p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
//						mediumConstraintViolations ++;
//					}
//					if (cp.getPriority() == ConstraintPriority.low) {
//						p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
//						lowConstraintViolations ++;
//					}

				}
			}
		}
	}
	private void checkCustomConstraints() {
		String[] intermediate = this.getIntermediate();
		for (CustomConstraint cp : customConstraints) {
			if (!cp.mustAppear()) {
				int found = 0;
				for (String i : intermediate) {
					//Matcher matcher = pattern.matcher(i);
					Matcher matcher = cp.getPattern().matcher(i);
					if (matcher.find()) {
						found ++;
					}
				}

				int p=1;
				if (cp.getPriority() == ConstraintPriority.high) {
					p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
					highConstraintViolations  = highConstraintViolations + found;
				}
				if (cp.getPriority() == ConstraintPriority.medium) {
					p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
					mediumConstraintViolations  = mediumConstraintViolations + found;
				}
				if (cp.getPriority() == ConstraintPriority.low) {
					p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
					lowConstraintViolations  = lowConstraintViolations + found;
				}

				fitness = fitness + (found *p);

			}else {
				boolean found = false;
				for (String i : intermediate) {
					Matcher matcher = cp.getPattern().matcher(i);
					if (matcher.find()) {
						found = true;
						break;
					}
				}
				if (!found) {
					int p=1;
					if (cp.getPriority() == ConstraintPriority.high) {
						p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
						highConstraintViolations ++;
					}
					if (cp.getPriority() == ConstraintPriority.medium) {
						p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
						mediumConstraintViolations ++;
					}
					if (cp.getPriority() == ConstraintPriority.low) {
						p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
						lowConstraintViolations ++;
					}

					fitness = fitness + p;
				}
			}
		}
	}
	private void checkImbalance() {
		for (int[][] p : participants) {
			for (int d=0; d < 7; d++) {
				for (Group g : Group.values()) {
					if (p[d][g.ordinal()]>targets[g.ordinal()]) {
						int over = p[d][g.ordinal()]-targets[g.ordinal()];
						groupImbalanced=groupImbalanced+over;
						fitness = fitness +(over *ProblemParameters.PENALTY_GROUP_IMBALANCE);
					}
				}
			}
		}
	}

	private boolean checkLate(Gene g) {
		if (g.driver.getDuty(g.slot.getWeek())==1) {
			return true;
		}
		return false;
	}

	public boolean checkExpiry(Gene g) {
		int week = g.slot.getWeek();
		if (g.driver.finalYear()) {
			if(week >  g.driver.getExpiresWeek()) {
				return true;
			}
		}
		return false;

	}

	public void initParticipants() {
		participants = new int[ProblemParameters.WEEKS][][];
		for (int x=0;x < participants.length; x++ ) {
			participants[x] = new int[7][];
			for (int d=0; d < 7; d++) {
				participants[x][d] = new int[Group.values().length];
			}
		}

	}
	public void init() {

		modified = true;
		initParticipants();
		//Random init
		free = new ArrayList<TrainingSlot>();
		chromosome = new ArrayList<Gene>();

		try {
			free.addAll(SlotFactory.getSlotSet() ) ;

			//Now create genes
			for (Driver d : DriverFactory.getDriverList()) {
				Gene g = new Gene();
				g.driver = d;
				g.slot = getRndUnalloc(d);
				chromosome.add(g);
			}

		} catch (Exception e) {
			e.printStackTrace();
		}
		intermediateBuffer = new String[chromosome.size()];
	}

	private TrainingSlot getRndUnalloc(Driver d) {
		//Bias towards early shift & unexpired

		int idx = rnd.nextInt(free.size());

		for (int tries =0; tries <=150; tries++) {
			TrainingSlot s = free.get(idx);
			int week = s.getWeek();
			if (d.finalYear()) {
				if (week <= d.getExpiresWeek())
					break;
			}else {

				int duty = d.getDuty(week);
				if (duty==2) {
					break;
				}
			}
			idx = rnd.nextInt(free.size());
		}
		return free.remove(idx);
	}

	public void mutate() {
		modified = true;
		//mutate
		if (rnd.nextBoolean()) {
			//Sawp
			Gene g1 = chromosome.get(rnd.nextInt(chromosome.size()));


			//Bias towards slot issues
			if (rnd.nextBoolean()) {
				int t=0;
				while ((g1.driver.getDuty(g1.slot.getWeek())==1) &&( t <11)){
					g1 = chromosome.get(rnd.nextInt(chromosome.size()));
					t++;
				}
			}

			Gene g2 = chromosome.get(rnd.nextInt(chromosome.size()));
			TrainingSlot tmp = g1.slot;
			g1.slot = g2.slot;
			g2.slot = tmp;
		}else {
			//Swap to unalloc
			Gene g1 = chromosome.get(rnd.nextInt(chromosome.size()));
			TrainingSlot tmp = free.remove(rnd.nextInt(free.size()));
			free.add(g1.slot);
			g1.slot = tmp;
		}
	}



	public Individual(Individual p1, Individual p2) throws Exception {
		initParticipants();
		modified = true;
		//Crossover constructor
		free = new ArrayList<TrainingSlot>();
		free.addAll(SlotFactory.getSlotSet()) ;
		chromosome = new ArrayList<Gene>();

		for (int count =0; count <  p1.chromosome.size(); count ++) {
			Gene g  = new Gene();
			Gene p1g = p1.chromosome.get(count);
			Gene p2g = p2.chromosome.get(count);
			g.driver = p1g.driver;
			if (rnd.nextBoolean()) {
				//Add p1
				TrainingSlot s = p1g.slot;
				if (free.contains(s)) {
					g.slot = s;
					free.remove(s);
				}else {
					s = p2g.slot;
					if (free.contains(s)) {
						g.slot = s;
						free.remove(s);
					}else {
						s = free.remove(0);
						g.slot=s;
					}
				}
			}else{
				//Add p2
				TrainingSlot s = p2g.slot;
				if (free.contains(s)) {
					g.slot = s;
					free.remove(s);
				}else {
					s = p1g.slot;
					if (free.contains(s)) {
						g.slot = s;
						free.remove(s);
					}else {
						s = free.remove(0);
						g.slot=s;
					}
				}
			}
			chromosome.add(g);
		}
		intermediateBuffer = new String[chromosome.size()];
	}

	public void printSummary() {
		if (modified) {
			this.fitness();
		};
		//...
		System.out.println("CPC Plan");
		System.out.println("Issues :");
		System.out.println("CPC on lates shift: \t" +lates); 
		System.out.println("License expired before training: \t"+expired);
		System.out.println("Imbalanced group places: \t"+groupImbalanced);
		System.out.println("Low Constraint violations: \t"+lowConstraintViolations);
		System.out.println("Medium Constraint violations: \t"+mediumConstraintViolations);
		System.out.println("High Constraint violations: \t"+highConstraintViolations);

	}

	public String findIntermediate(String[] intermediate, Gene g) {
		String drvId = g.driver.getID();
		for (String s : intermediate) {
			if (s.contains(drvId))
				return s;
		}
		return null;
	}
	public void printSol() {
		
		String[] intermediate = this.getIntermediate();
		
		System.out.println("Plan by week / day ");
		System.out.println("Week , Day , Driver ID ,Group,Duty,Expiry Week, Final Year" );
		//Print by week
		for (int week =0; week < ProblemParameters.WEEKS; week++) {
			for (int day =0; day < 7; day ++) {
				for (Gene g : chromosome) {
					if ((g.slot.getWeek() == week) && (g.slot.getDay()==day)) {

						System.out.print(week + "," +day +"," + g.driver.getID() +"," +g.driver.group().name() + "," +g.driver.getDuty(week)+","+g.driver.getExpiresWeek() + ","+g.driver.finalYear() );
						if (this.checkExpiry(g))
								System.out.print("\tLICENSE EXPIRED!");

						if (this.checkLate(g))
							System.out.print("\tON LATE DUTY!");
						
						System.out.println();
						String inter = findIntermediate(intermediate,g);
						
						//Now check custom constraints
						this.checkCustomConstraints(g, inter);
						
//						System.out.println("\t"+inter);
					}
				}
			}
		}

		
		
//		System.out.println("Plan by week / day ");
//		System.out.println("Week , Day , Driver ID ,Group,Duty,Expiry Week, Final Year" );
//		//Print by week
//		for (int week =0; week < ProblemParameters.WEEKS; week++) {
//			for (int day =0; day < 7; day ++) {
//				for (Gene g : chromosome) {
//					if ((g.slot.getWeek() == week) && (g.slot.getDay()==day)) {
//
//						System.out.print(week + "," +day +"," + g.driver.getID() +"," +g.driver.group().name() + "," +g.driver.getDuty(week)+","+g.driver.getExpiresWeek() + ","+g.driver.finalYear() );
//						if (g.driver.finalYear())
//							if(g.driver.getExpiresWeek() < week)
//								System.out.print(", LICENSE EXPIRED!");
//
//						if (g.driver.getDuty(week)==1)
//							System.out.print(", ON LATE DUTY!");
//						System.out.println();
//					}
//				}
//			}
//		}
//
//		System.out.println("Additional constraints:");
//		String[] intermediate = this.getIntermediate();
//
//		for (CustomConstraint cp: customConstraints) {
//			//Pattern pattern = Pattern.compile(cp.getRegex(), Pattern.CASE_INSENSITIVE);
//			System.out.print("'"+cp.getSource());
//			if (cp.mustAppear()) {
//				boolean found = false;
//				for (String i : intermediate) {
//					Matcher matcher = cp.getPattern().matcher(i);
//					if (matcher.find()) 
//						found = true;
//				}
//				if (found) 
//					System.out.println( "' has been met." );
//				else
//					System.out.println( "' has not been met." );
//			}else {
//				boolean found = false;
//				for (String i : intermediate) {
//					Matcher matcher = cp.getPattern().matcher(i);
//					if (matcher.find()) 
//						found = true;
//				}
//
//				if (!found) 
//					System.out.println("' has been met." );
//				else
//					System.out.println("' has not been met." );
//
//				
//			}
//
//		}
	}

	private String[] intermediateBuffer;

	public String[] getIntermediate() {
		//Print by week
		int c=0;
		for (Gene g : chromosome) {
			String w =""+ g.slot.getWeek();
			if (w.length()<2) w ="0"+w;

			String xw = ""+g.driver.getExpiresWeek();
			if (xw.length()<2) xw ="0"+xw;
			int fy=0;
			if (g.driver.finalYear()) fy=1;

			//intermediateBuffer[c] =  (":WK:"+w + ":DY:" +g.slot.getDay() +":ID:" + g.driver.getID() +":GR:" +g.driver.group().name() + ":DT:" +g.driver.getDuty(g.slot.getWeek())+":XW:"+xw + ":FY:"+fy );	
			intermediateBuffer[c] =  (
					":ID:" + g.driver.getID() +
					":GR:" +g.driver.group().name() + 
					":WK:"+w + 
					":DY:" +g.slot.getDay() +
					":DT:" +g.driver.getDuty(g.slot.getWeek())+
					":XW:"+xw + 
					":FY:"+fy );	

			c++;
		}
		//		String buffer = "";
		//		for (String s : intermediateBuffer) {
		//			//			buffer = buffer + s;
		//		}
		return intermediateBuffer;
	}


	public Individual (Individual other) {
		initParticipants();
		//Copy constructor
		this.chromosome = new ArrayList<Gene>();
		for (Gene og : other.chromosome) {
			Gene ng = new Gene();
			ng.driver = og.driver;
			ng.slot = og.slot;
			this.chromosome.add(ng);
		}

		this.free = new ArrayList<TrainingSlot>();
		for (TrainingSlot s : other.free)
			this.free.add(s);

		modified = true;
		intermediateBuffer = new String[chromosome.size()];
	}

	private void verify() throws Exception {
		/* Verify that the chromsome contains a valid solution */
		ArrayList<TrainingSlot> slots = SlotFactory.getSlotSet();


		for (Gene g : chromosome) {
			if (g.driver == null)
				throw new Exception("Null driver in gene");

			if (g.slot == null)
				throw new Exception("Null slot in gene");


			if (slots.contains(g.slot)) {
				slots.remove(slots.indexOf(g.slot));
			}else {
				throw new Exception("Duplicated slot ");
			}
		}

		for (TrainingSlot s : free) {
			if (slots.contains(s)) {
				slots.remove(slots.indexOf(s));
			}else {
				throw new Exception("Duplicate unallocated slot");
			}
		}
		if (slots.size() !=0) {
			throw new Exception("Extra slots left");
		}
	}
	public String stats() {
		return  "fit," +fitness +",lates,"+lates +",expired,"+expired +",imbalance,"+groupImbalanced +",low," +lowConstraintViolations +",med," +mediumConstraintViolations+",high," +highConstraintViolations;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-02-20 23:03:20.428
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-02-20 23:03:20.428
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-20 23:03:20.462
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Random;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Individual {
	private Random rnd = new Random();
	private ArrayList<Gene> chromosome;
	private ArrayList<TrainingSlot> free;
	private boolean modified = true;
	private int fitness;
	private int expired=0;
	private int lates=0;
	private int groupImbalanced=0;
	private int lowConstraintViolations=0;
	private int mediumConstraintViolations=0;
	private int highConstraintViolations=0;

	private int[][][]participants = new int[ProblemParameters.WEEKS][][];
	private static ArrayList<CustomConstraint> customConstraints;


	private static int[] targets=null;//Targets from each group

	//	public static void loadConstraints() {
	//		//		constraintsPresent = new ArrayList<String>();
	//		//		constraintsNotPresent = new ArrayList<String>();
	//		customConstraints = new ArrayList<CustomConstraint>();
	//		String fileName = "./constraints.txt";
	//
	//
	//		try (BufferedReader br = new BufferedReader(new FileReader(fileName))) {
	//			String line;
	//			int lineNo=1;
	//			while ((line = br.readLine()) != null) {
	//				//process line
	//				CustomConstraint cp=null;
	//				try {
	//					cp = Parser.parse(line);
	//
	//				}catch(Exception e) {
	//					System.out.println("Error reading constraints \nLine no " + lineNo +" "+ e.getMessage());
	//					System.exit(-1);
	//				}
	//				if (cp != null) {
	//					customConstraints.add(cp);
	//					//					char ch = line.charAt(0);
	//					//					line = line.substring(1);
	//					//					if (ch=='+') {
	//					//						constraintsPresent.add(line);
	//					//					}
	//					//					if (ch=='-') {
	//					//						constraintsNotPresent.add(line);
	//					//					}
	//				}
	//				lineNo++;
	//
	//			}
	//		} catch (FileNotFoundException e) {
	//			e.printStackTrace();
	//		} catch (IOException e) {
	//			e.printStackTrace();
	//		}
	//
	//	}
	public static void setConstraints(ArrayList<String> text) {
		//		constraintsPresent = new ArrayList<String>();
		//		constraintsNotPresent = new ArrayList<String>();
		customConstraints = new ArrayList<CustomConstraint>();


		int lineNo=1;
		for (String line : text) {
			//process line
			CustomConstraint cp=null;
			try {
				cp = Parser.parse(line);

			}catch(Exception e) {
				System.out.println("Error reading constraints \nLine no " + lineNo +" "+ e.getMessage());
				System.exit(-1);
			}
			if (cp != null) {
				customConstraints.add(cp);
			}
			lineNo++;
		}
	}
	public Individual() {
		init();
		if (targets==null) {
			int tDrivers = DriverFactory.getDriverList().size();
			targets = new int[Group.values().length];
			for(Group g :Group.values()) {
				int count=0;
				for (Driver d : DriverFactory.getDriverList()) {
					if (d.group()==g)					
						count++;
				}
				float t =  (count/(float)tDrivers)*ProblemParameters.TRAINING_PLACES;
				targets[g.ordinal()] = Math.round(t);
				targets[g.ordinal()]++;
				//				System.out.println("Target " + g.name() + " "+targets[g.ordinal()]);
			}

		}

	}
	public int fitness() {
		//		try {
		//			this.verify();
		//		} catch (Exception e) {
		//			// TODO Auto-generated catch block
		//			e.printStackTrace();
		//			System.exit(-1);
		//		}

		if (modified) {
			ProblemParameters.EVALS++;
			modified = false;
			fitness =0;
			lates=0;
			expired=0;
			groupImbalanced=0;
			lowConstraintViolations=0;
			mediumConstraintViolations=0;
			highConstraintViolations=0;
			//Count participants from each group.
			for (int x=0;x < participants.length; x++ ) {
				for (int d=0; d < 7; d++) {
					for (int g =0; g < Group.values().length; g++ )
						participants[x][d][g] = 0;
				}
			}


			for (Gene g : chromosome) {
				
				if (checkLate(g)) {
					fitness = fitness + ProblemParameters.PENALTY_LATE_SHIFT;
					lates++;
				}
				//Check for training after expiry
				if (checkExpiry(g)) {
					fitness = fitness + ProblemParameters.PENALTY_EXPIRED_LICENSE;
					expired++;
				}else {
				//Encourage training as far before expiry as possible
					(g.slot.getWeek()/g.driver.getExpiresWeek())*ProblemParameters.p
				}
				//Log participation
				participants[g.slot.getWeek()][g.slot.getDay()][g.driver.group().ordinal()]++;

			}
			//Check for imbalance in participants
			checkImbalance();
			checkCustomConstraints();
		}
		return fitness;
	}
	
	private void checkCustomConstraints(Gene g, String intermediate) {
		for (CustomConstraint cp : customConstraints) {
			if (!cp.mustAppear()) {
				int found = 0;
					//Matcher matcher = pattern.matcher(i);
					Matcher matcher = cp.getPattern().matcher(intermediate);
					if (matcher.find()) {
						found ++;
					}
				

				int p=1;
				if (found > 0)
					System.out.println("\t Violation " + cp.getSource() );
//				if (cp.getPriority() == ConstraintPriority.high) {
//					p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
//					highConstraintViolations  = highConstraintViolations + found;
//				}
//				if (cp.getPriority() == ConstraintPriority.medium) {
//					p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
//					mediumConstraintViolations  = mediumConstraintViolations + found;
//				}
//				if (cp.getPriority() == ConstraintPriority.low) {
//					p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
//					lowConstraintViolations  = lowConstraintViolations + found;
//				}


			}else {
				boolean found = false;
					Matcher matcher = cp.getPattern().matcher(intermediate);
					if (matcher.find()) {
						found = true;
						break;
					}
				
				if (!found) {
					int p=1;
					System.out.println("\t Violation " + cp.getSource() );
//					if (cp.getPriority() == ConstraintPriority.high) {
//						p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
//						highConstraintViolations ++;
//					}
//					if (cp.getPriority() == ConstraintPriority.medium) {
//						p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
//						mediumConstraintViolations ++;
//					}
//					if (cp.getPriority() == ConstraintPriority.low) {
//						p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
//						lowConstraintViolations ++;
//					}

				}
			}
		}
	}
	private void checkCustomConstraints() {
		String[] intermediate = this.getIntermediate();
		for (CustomConstraint cp : customConstraints) {
			if (!cp.mustAppear()) {
				int found = 0;
				for (String i : intermediate) {
					//Matcher matcher = pattern.matcher(i);
					Matcher matcher = cp.getPattern().matcher(i);
					if (matcher.find()) {
						found ++;
					}
				}

				int p=1;
				if (cp.getPriority() == ConstraintPriority.high) {
					p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
					highConstraintViolations  = highConstraintViolations + found;
				}
				if (cp.getPriority() == ConstraintPriority.medium) {
					p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
					mediumConstraintViolations  = mediumConstraintViolations + found;
				}
				if (cp.getPriority() == ConstraintPriority.low) {
					p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
					lowConstraintViolations  = lowConstraintViolations + found;
				}

				fitness = fitness + (found *p);

			}else {
				boolean found = false;
				for (String i : intermediate) {
					Matcher matcher = cp.getPattern().matcher(i);
					if (matcher.find()) {
						found = true;
						break;
					}
				}
				if (!found) {
					int p=1;
					if (cp.getPriority() == ConstraintPriority.high) {
						p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
						highConstraintViolations ++;
					}
					if (cp.getPriority() == ConstraintPriority.medium) {
						p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
						mediumConstraintViolations ++;
					}
					if (cp.getPriority() == ConstraintPriority.low) {
						p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
						lowConstraintViolations ++;
					}

					fitness = fitness + p;
				}
			}
		}
	}
	private void checkImbalance() {
		for (int[][] p : participants) {
			for (int d=0; d < 7; d++) {
				for (Group g : Group.values()) {
					if (p[d][g.ordinal()]>targets[g.ordinal()]) {
						int over = p[d][g.ordinal()]-targets[g.ordinal()];
						groupImbalanced=groupImbalanced+over;
						fitness = fitness +(over *ProblemParameters.PENALTY_GROUP_IMBALANCE);
					}
				}
			}
		}
	}

	private boolean checkLate(Gene g) {
		if (g.driver.getDuty(g.slot.getWeek())==1) {
			return true;
		}
		return false;
	}

	public boolean checkExpiry(Gene g) {
		int week = g.slot.getWeek();
		if (g.driver.finalYear()) {
			if(week >  g.driver.getExpiresWeek()) {
				return true;
			}
		}
		return false;

	}

	public void initParticipants() {
		participants = new int[ProblemParameters.WEEKS][][];
		for (int x=0;x < participants.length; x++ ) {
			participants[x] = new int[7][];
			for (int d=0; d < 7; d++) {
				participants[x][d] = new int[Group.values().length];
			}
		}

	}
	public void init() {

		modified = true;
		initParticipants();
		//Random init
		free = new ArrayList<TrainingSlot>();
		chromosome = new ArrayList<Gene>();

		try {
			free.addAll(SlotFactory.getSlotSet() ) ;

			//Now create genes
			for (Driver d : DriverFactory.getDriverList()) {
				Gene g = new Gene();
				g.driver = d;
				g.slot = getRndUnalloc(d);
				chromosome.add(g);
			}

		} catch (Exception e) {
			e.printStackTrace();
		}
		intermediateBuffer = new String[chromosome.size()];
	}

	private TrainingSlot getRndUnalloc(Driver d) {
		//Bias towards early shift & unexpired

		int idx = rnd.nextInt(free.size());

		for (int tries =0; tries <=150; tries++) {
			TrainingSlot s = free.get(idx);
			int week = s.getWeek();
			if (d.finalYear()) {
				if (week <= d.getExpiresWeek())
					break;
			}else {

				int duty = d.getDuty(week);
				if (duty==2) {
					break;
				}
			}
			idx = rnd.nextInt(free.size());
		}
		return free.remove(idx);
	}

	public void mutate() {
		modified = true;
		//mutate
		if (rnd.nextBoolean()) {
			//Sawp
			Gene g1 = chromosome.get(rnd.nextInt(chromosome.size()));


			//Bias towards slot issues
			if (rnd.nextBoolean()) {
				int t=0;
				while ((g1.driver.getDuty(g1.slot.getWeek())==1) &&( t <11)){
					g1 = chromosome.get(rnd.nextInt(chromosome.size()));
					t++;
				}
			}

			Gene g2 = chromosome.get(rnd.nextInt(chromosome.size()));
			TrainingSlot tmp = g1.slot;
			g1.slot = g2.slot;
			g2.slot = tmp;
		}else {
			//Swap to unalloc
			Gene g1 = chromosome.get(rnd.nextInt(chromosome.size()));
			TrainingSlot tmp = free.remove(rnd.nextInt(free.size()));
			free.add(g1.slot);
			g1.slot = tmp;
		}
	}



	public Individual(Individual p1, Individual p2) throws Exception {
		initParticipants();
		modified = true;
		//Crossover constructor
		free = new ArrayList<TrainingSlot>();
		free.addAll(SlotFactory.getSlotSet()) ;
		chromosome = new ArrayList<Gene>();

		for (int count =0; count <  p1.chromosome.size(); count ++) {
			Gene g  = new Gene();
			Gene p1g = p1.chromosome.get(count);
			Gene p2g = p2.chromosome.get(count);
			g.driver = p1g.driver;
			if (rnd.nextBoolean()) {
				//Add p1
				TrainingSlot s = p1g.slot;
				if (free.contains(s)) {
					g.slot = s;
					free.remove(s);
				}else {
					s = p2g.slot;
					if (free.contains(s)) {
						g.slot = s;
						free.remove(s);
					}else {
						s = free.remove(0);
						g.slot=s;
					}
				}
			}else{
				//Add p2
				TrainingSlot s = p2g.slot;
				if (free.contains(s)) {
					g.slot = s;
					free.remove(s);
				}else {
					s = p1g.slot;
					if (free.contains(s)) {
						g.slot = s;
						free.remove(s);
					}else {
						s = free.remove(0);
						g.slot=s;
					}
				}
			}
			chromosome.add(g);
		}
		intermediateBuffer = new String[chromosome.size()];
	}

	public void printSummary() {
		if (modified) {
			this.fitness();
		};
		//...
		System.out.println("CPC Plan");
		System.out.println("Issues :");
		System.out.println("CPC on lates shift: \t" +lates); 
		System.out.println("License expired before training: \t"+expired);
		System.out.println("Imbalanced group places: \t"+groupImbalanced);
		System.out.println("Low Constraint violations: \t"+lowConstraintViolations);
		System.out.println("Medium Constraint violations: \t"+mediumConstraintViolations);
		System.out.println("High Constraint violations: \t"+highConstraintViolations);

	}

	public String findIntermediate(String[] intermediate, Gene g) {
		String drvId = g.driver.getID();
		for (String s : intermediate) {
			if (s.contains(drvId))
				return s;
		}
		return null;
	}
	public void printSol() {
		
		String[] intermediate = this.getIntermediate();
		
		System.out.println("Plan by week / day ");
		System.out.println("Week , Day , Driver ID ,Group,Duty,Expiry Week, Final Year" );
		//Print by week
		for (int week =0; week < ProblemParameters.WEEKS; week++) {
			for (int day =0; day < 7; day ++) {
				for (Gene g : chromosome) {
					if ((g.slot.getWeek() == week) && (g.slot.getDay()==day)) {

						System.out.print(week + "," +day +"," + g.driver.getID() +"," +g.driver.group().name() + "," +g.driver.getDuty(week)+","+g.driver.getExpiresWeek() + ","+g.driver.finalYear() );
						if (this.checkExpiry(g))
								System.out.print("\tLICENSE EXPIRED!");

						if (this.checkLate(g))
							System.out.print("\tON LATE DUTY!");
						
						System.out.println();
						String inter = findIntermediate(intermediate,g);
						
						//Now check custom constraints
						this.checkCustomConstraints(g, inter);
						
//						System.out.println("\t"+inter);
					}
				}
			}
		}

		
		
//		System.out.println("Plan by week / day ");
//		System.out.println("Week , Day , Driver ID ,Group,Duty,Expiry Week, Final Year" );
//		//Print by week
//		for (int week =0; week < ProblemParameters.WEEKS; week++) {
//			for (int day =0; day < 7; day ++) {
//				for (Gene g : chromosome) {
//					if ((g.slot.getWeek() == week) && (g.slot.getDay()==day)) {
//
//						System.out.print(week + "," +day +"," + g.driver.getID() +"," +g.driver.group().name() + "," +g.driver.getDuty(week)+","+g.driver.getExpiresWeek() + ","+g.driver.finalYear() );
//						if (g.driver.finalYear())
//							if(g.driver.getExpiresWeek() < week)
//								System.out.print(", LICENSE EXPIRED!");
//
//						if (g.driver.getDuty(week)==1)
//							System.out.print(", ON LATE DUTY!");
//						System.out.println();
//					}
//				}
//			}
//		}
//
//		System.out.println("Additional constraints:");
//		String[] intermediate = this.getIntermediate();
//
//		for (CustomConstraint cp: customConstraints) {
//			//Pattern pattern = Pattern.compile(cp.getRegex(), Pattern.CASE_INSENSITIVE);
//			System.out.print("'"+cp.getSource());
//			if (cp.mustAppear()) {
//				boolean found = false;
//				for (String i : intermediate) {
//					Matcher matcher = cp.getPattern().matcher(i);
//					if (matcher.find()) 
//						found = true;
//				}
//				if (found) 
//					System.out.println( "' has been met." );
//				else
//					System.out.println( "' has not been met." );
//			}else {
//				boolean found = false;
//				for (String i : intermediate) {
//					Matcher matcher = cp.getPattern().matcher(i);
//					if (matcher.find()) 
//						found = true;
//				}
//
//				if (!found) 
//					System.out.println("' has been met." );
//				else
//					System.out.println("' has not been met." );
//
//				
//			}
//
//		}
	}

	private String[] intermediateBuffer;

	public String[] getIntermediate() {
		//Print by week
		int c=0;
		for (Gene g : chromosome) {
			String w =""+ g.slot.getWeek();
			if (w.length()<2) w ="0"+w;

			String xw = ""+g.driver.getExpiresWeek();
			if (xw.length()<2) xw ="0"+xw;
			int fy=0;
			if (g.driver.finalYear()) fy=1;

			//intermediateBuffer[c] =  (":WK:"+w + ":DY:" +g.slot.getDay() +":ID:" + g.driver.getID() +":GR:" +g.driver.group().name() + ":DT:" +g.driver.getDuty(g.slot.getWeek())+":XW:"+xw + ":FY:"+fy );	
			intermediateBuffer[c] =  (
					":ID:" + g.driver.getID() +
					":GR:" +g.driver.group().name() + 
					":WK:"+w + 
					":DY:" +g.slot.getDay() +
					":DT:" +g.driver.getDuty(g.slot.getWeek())+
					":XW:"+xw + 
					":FY:"+fy );	

			c++;
		}
		//		String buffer = "";
		//		for (String s : intermediateBuffer) {
		//			//			buffer = buffer + s;
		//		}
		return intermediateBuffer;
	}


	public Individual (Individual other) {
		initParticipants();
		//Copy constructor
		this.chromosome = new ArrayList<Gene>();
		for (Gene og : other.chromosome) {
			Gene ng = new Gene();
			ng.driver = og.driver;
			ng.slot = og.slot;
			this.chromosome.add(ng);
		}

		this.free = new ArrayList<TrainingSlot>();
		for (TrainingSlot s : other.free)
			this.free.add(s);

		modified = true;
		intermediateBuffer = new String[chromosome.size()];
	}

	private void verify() throws Exception {
		/* Verify that the chromsome contains a valid solution */
		ArrayList<TrainingSlot> slots = SlotFactory.getSlotSet();


		for (Gene g : chromosome) {
			if (g.driver == null)
				throw new Exception("Null driver in gene");

			if (g.slot == null)
				throw new Exception("Null slot in gene");


			if (slots.contains(g.slot)) {
				slots.remove(slots.indexOf(g.slot));
			}else {
				throw new Exception("Duplicated slot ");
			}
		}

		for (TrainingSlot s : free) {
			if (slots.contains(s)) {
				slots.remove(slots.indexOf(s));
			}else {
				throw new Exception("Duplicate unallocated slot");
			}
		}
		if (slots.size() !=0) {
			throw new Exception("Extra slots left");
		}
	}
	public String stats() {
		return  "fit," +fitness +",lates,"+lates +",expired,"+expired +",imbalance,"+groupImbalanced +",low," +lowConstraintViolations +",med," +mediumConstraintViolations+",high," +highConstraintViolations;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-02-20 23:03:20.462
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-02-20 23:03:20.462
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-20 23:03:22.371
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Random;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Individual {
	private Random rnd = new Random();
	private ArrayList<Gene> chromosome;
	private ArrayList<TrainingSlot> free;
	private boolean modified = true;
	private int fitness;
	private int expired=0;
	private int lates=0;
	private int groupImbalanced=0;
	private int lowConstraintViolations=0;
	private int mediumConstraintViolations=0;
	private int highConstraintViolations=0;

	private int[][][]participants = new int[ProblemParameters.WEEKS][][];
	private static ArrayList<CustomConstraint> customConstraints;


	private static int[] targets=null;//Targets from each group

	//	public static void loadConstraints() {
	//		//		constraintsPresent = new ArrayList<String>();
	//		//		constraintsNotPresent = new ArrayList<String>();
	//		customConstraints = new ArrayList<CustomConstraint>();
	//		String fileName = "./constraints.txt";
	//
	//
	//		try (BufferedReader br = new BufferedReader(new FileReader(fileName))) {
	//			String line;
	//			int lineNo=1;
	//			while ((line = br.readLine()) != null) {
	//				//process line
	//				CustomConstraint cp=null;
	//				try {
	//					cp = Parser.parse(line);
	//
	//				}catch(Exception e) {
	//					System.out.println("Error reading constraints \nLine no " + lineNo +" "+ e.getMessage());
	//					System.exit(-1);
	//				}
	//				if (cp != null) {
	//					customConstraints.add(cp);
	//					//					char ch = line.charAt(0);
	//					//					line = line.substring(1);
	//					//					if (ch=='+') {
	//					//						constraintsPresent.add(line);
	//					//					}
	//					//					if (ch=='-') {
	//					//						constraintsNotPresent.add(line);
	//					//					}
	//				}
	//				lineNo++;
	//
	//			}
	//		} catch (FileNotFoundException e) {
	//			e.printStackTrace();
	//		} catch (IOException e) {
	//			e.printStackTrace();
	//		}
	//
	//	}
	public static void setConstraints(ArrayList<String> text) {
		//		constraintsPresent = new ArrayList<String>();
		//		constraintsNotPresent = new ArrayList<String>();
		customConstraints = new ArrayList<CustomConstraint>();


		int lineNo=1;
		for (String line : text) {
			//process line
			CustomConstraint cp=null;
			try {
				cp = Parser.parse(line);

			}catch(Exception e) {
				System.out.println("Error reading constraints \nLine no " + lineNo +" "+ e.getMessage());
				System.exit(-1);
			}
			if (cp != null) {
				customConstraints.add(cp);
			}
			lineNo++;
		}
	}
	public Individual() {
		init();
		if (targets==null) {
			int tDrivers = DriverFactory.getDriverList().size();
			targets = new int[Group.values().length];
			for(Group g :Group.values()) {
				int count=0;
				for (Driver d : DriverFactory.getDriverList()) {
					if (d.group()==g)					
						count++;
				}
				float t =  (count/(float)tDrivers)*ProblemParameters.TRAINING_PLACES;
				targets[g.ordinal()] = Math.round(t);
				targets[g.ordinal()]++;
				//				System.out.println("Target " + g.name() + " "+targets[g.ordinal()]);
			}

		}

	}
	public int fitness() {
		//		try {
		//			this.verify();
		//		} catch (Exception e) {
		//			// TODO Auto-generated catch block
		//			e.printStackTrace();
		//			System.exit(-1);
		//		}

		if (modified) {
			ProblemParameters.EVALS++;
			modified = false;
			fitness =0;
			lates=0;
			expired=0;
			groupImbalanced=0;
			lowConstraintViolations=0;
			mediumConstraintViolations=0;
			highConstraintViolations=0;
			//Count participants from each group.
			for (int x=0;x < participants.length; x++ ) {
				for (int d=0; d < 7; d++) {
					for (int g =0; g < Group.values().length; g++ )
						participants[x][d][g] = 0;
				}
			}


			for (Gene g : chromosome) {
				
				if (checkLate(g)) {
					fitness = fitness + ProblemParameters.PENALTY_LATE_SHIFT;
					lates++;
				}
				//Check for training after expiry
				if (checkExpiry(g)) {
					fitness = fitness + ProblemParameters.PENALTY_EXPIRED_LICENSE;
					expired++;
				}else {
				//Encourage training as far before expiry as possible
					(g.slot.getWeek()/g.driver.getExpiresWeek())*ProblemParameters.PENALTY_ADVANCE_FINAL_WEEK
				}
				//Log participation
				participants[g.slot.getWeek()][g.slot.getDay()][g.driver.group().ordinal()]++;

			}
			//Check for imbalance in participants
			checkImbalance();
			checkCustomConstraints();
		}
		return fitness;
	}
	
	private void checkCustomConstraints(Gene g, String intermediate) {
		for (CustomConstraint cp : customConstraints) {
			if (!cp.mustAppear()) {
				int found = 0;
					//Matcher matcher = pattern.matcher(i);
					Matcher matcher = cp.getPattern().matcher(intermediate);
					if (matcher.find()) {
						found ++;
					}
				

				int p=1;
				if (found > 0)
					System.out.println("\t Violation " + cp.getSource() );
//				if (cp.getPriority() == ConstraintPriority.high) {
//					p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
//					highConstraintViolations  = highConstraintViolations + found;
//				}
//				if (cp.getPriority() == ConstraintPriority.medium) {
//					p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
//					mediumConstraintViolations  = mediumConstraintViolations + found;
//				}
//				if (cp.getPriority() == ConstraintPriority.low) {
//					p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
//					lowConstraintViolations  = lowConstraintViolations + found;
//				}


			}else {
				boolean found = false;
					Matcher matcher = cp.getPattern().matcher(intermediate);
					if (matcher.find()) {
						found = true;
						break;
					}
				
				if (!found) {
					int p=1;
					System.out.println("\t Violation " + cp.getSource() );
//					if (cp.getPriority() == ConstraintPriority.high) {
//						p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
//						highConstraintViolations ++;
//					}
//					if (cp.getPriority() == ConstraintPriority.medium) {
//						p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
//						mediumConstraintViolations ++;
//					}
//					if (cp.getPriority() == ConstraintPriority.low) {
//						p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
//						lowConstraintViolations ++;
//					}

				}
			}
		}
	}
	private void checkCustomConstraints() {
		String[] intermediate = this.getIntermediate();
		for (CustomConstraint cp : customConstraints) {
			if (!cp.mustAppear()) {
				int found = 0;
				for (String i : intermediate) {
					//Matcher matcher = pattern.matcher(i);
					Matcher matcher = cp.getPattern().matcher(i);
					if (matcher.find()) {
						found ++;
					}
				}

				int p=1;
				if (cp.getPriority() == ConstraintPriority.high) {
					p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
					highConstraintViolations  = highConstraintViolations + found;
				}
				if (cp.getPriority() == ConstraintPriority.medium) {
					p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
					mediumConstraintViolations  = mediumConstraintViolations + found;
				}
				if (cp.getPriority() == ConstraintPriority.low) {
					p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
					lowConstraintViolations  = lowConstraintViolations + found;
				}

				fitness = fitness + (found *p);

			}else {
				boolean found = false;
				for (String i : intermediate) {
					Matcher matcher = cp.getPattern().matcher(i);
					if (matcher.find()) {
						found = true;
						break;
					}
				}
				if (!found) {
					int p=1;
					if (cp.getPriority() == ConstraintPriority.high) {
						p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
						highConstraintViolations ++;
					}
					if (cp.getPriority() == ConstraintPriority.medium) {
						p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
						mediumConstraintViolations ++;
					}
					if (cp.getPriority() == ConstraintPriority.low) {
						p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
						lowConstraintViolations ++;
					}

					fitness = fitness + p;
				}
			}
		}
	}
	private void checkImbalance() {
		for (int[][] p : participants) {
			for (int d=0; d < 7; d++) {
				for (Group g : Group.values()) {
					if (p[d][g.ordinal()]>targets[g.ordinal()]) {
						int over = p[d][g.ordinal()]-targets[g.ordinal()];
						groupImbalanced=groupImbalanced+over;
						fitness = fitness +(over *ProblemParameters.PENALTY_GROUP_IMBALANCE);
					}
				}
			}
		}
	}

	private boolean checkLate(Gene g) {
		if (g.driver.getDuty(g.slot.getWeek())==1) {
			return true;
		}
		return false;
	}

	public boolean checkExpiry(Gene g) {
		int week = g.slot.getWeek();
		if (g.driver.finalYear()) {
			if(week >  g.driver.getExpiresWeek()) {
				return true;
			}
		}
		return false;

	}

	public void initParticipants() {
		participants = new int[ProblemParameters.WEEKS][][];
		for (int x=0;x < participants.length; x++ ) {
			participants[x] = new int[7][];
			for (int d=0; d < 7; d++) {
				participants[x][d] = new int[Group.values().length];
			}
		}

	}
	public void init() {

		modified = true;
		initParticipants();
		//Random init
		free = new ArrayList<TrainingSlot>();
		chromosome = new ArrayList<Gene>();

		try {
			free.addAll(SlotFactory.getSlotSet() ) ;

			//Now create genes
			for (Driver d : DriverFactory.getDriverList()) {
				Gene g = new Gene();
				g.driver = d;
				g.slot = getRndUnalloc(d);
				chromosome.add(g);
			}

		} catch (Exception e) {
			e.printStackTrace();
		}
		intermediateBuffer = new String[chromosome.size()];
	}

	private TrainingSlot getRndUnalloc(Driver d) {
		//Bias towards early shift & unexpired

		int idx = rnd.nextInt(free.size());

		for (int tries =0; tries <=150; tries++) {
			TrainingSlot s = free.get(idx);
			int week = s.getWeek();
			if (d.finalYear()) {
				if (week <= d.getExpiresWeek())
					break;
			}else {

				int duty = d.getDuty(week);
				if (duty==2) {
					break;
				}
			}
			idx = rnd.nextInt(free.size());
		}
		return free.remove(idx);
	}

	public void mutate() {
		modified = true;
		//mutate
		if (rnd.nextBoolean()) {
			//Sawp
			Gene g1 = chromosome.get(rnd.nextInt(chromosome.size()));


			//Bias towards slot issues
			if (rnd.nextBoolean()) {
				int t=0;
				while ((g1.driver.getDuty(g1.slot.getWeek())==1) &&( t <11)){
					g1 = chromosome.get(rnd.nextInt(chromosome.size()));
					t++;
				}
			}

			Gene g2 = chromosome.get(rnd.nextInt(chromosome.size()));
			TrainingSlot tmp = g1.slot;
			g1.slot = g2.slot;
			g2.slot = tmp;
		}else {
			//Swap to unalloc
			Gene g1 = chromosome.get(rnd.nextInt(chromosome.size()));
			TrainingSlot tmp = free.remove(rnd.nextInt(free.size()));
			free.add(g1.slot);
			g1.slot = tmp;
		}
	}



	public Individual(Individual p1, Individual p2) throws Exception {
		initParticipants();
		modified = true;
		//Crossover constructor
		free = new ArrayList<TrainingSlot>();
		free.addAll(SlotFactory.getSlotSet()) ;
		chromosome = new ArrayList<Gene>();

		for (int count =0; count <  p1.chromosome.size(); count ++) {
			Gene g  = new Gene();
			Gene p1g = p1.chromosome.get(count);
			Gene p2g = p2.chromosome.get(count);
			g.driver = p1g.driver;
			if (rnd.nextBoolean()) {
				//Add p1
				TrainingSlot s = p1g.slot;
				if (free.contains(s)) {
					g.slot = s;
					free.remove(s);
				}else {
					s = p2g.slot;
					if (free.contains(s)) {
						g.slot = s;
						free.remove(s);
					}else {
						s = free.remove(0);
						g.slot=s;
					}
				}
			}else{
				//Add p2
				TrainingSlot s = p2g.slot;
				if (free.contains(s)) {
					g.slot = s;
					free.remove(s);
				}else {
					s = p1g.slot;
					if (free.contains(s)) {
						g.slot = s;
						free.remove(s);
					}else {
						s = free.remove(0);
						g.slot=s;
					}
				}
			}
			chromosome.add(g);
		}
		intermediateBuffer = new String[chromosome.size()];
	}

	public void printSummary() {
		if (modified) {
			this.fitness();
		};
		//...
		System.out.println("CPC Plan");
		System.out.println("Issues :");
		System.out.println("CPC on lates shift: \t" +lates); 
		System.out.println("License expired before training: \t"+expired);
		System.out.println("Imbalanced group places: \t"+groupImbalanced);
		System.out.println("Low Constraint violations: \t"+lowConstraintViolations);
		System.out.println("Medium Constraint violations: \t"+mediumConstraintViolations);
		System.out.println("High Constraint violations: \t"+highConstraintViolations);

	}

	public String findIntermediate(String[] intermediate, Gene g) {
		String drvId = g.driver.getID();
		for (String s : intermediate) {
			if (s.contains(drvId))
				return s;
		}
		return null;
	}
	public void printSol() {
		
		String[] intermediate = this.getIntermediate();
		
		System.out.println("Plan by week / day ");
		System.out.println("Week , Day , Driver ID ,Group,Duty,Expiry Week, Final Year" );
		//Print by week
		for (int week =0; week < ProblemParameters.WEEKS; week++) {
			for (int day =0; day < 7; day ++) {
				for (Gene g : chromosome) {
					if ((g.slot.getWeek() == week) && (g.slot.getDay()==day)) {

						System.out.print(week + "," +day +"," + g.driver.getID() +"," +g.driver.group().name() + "," +g.driver.getDuty(week)+","+g.driver.getExpiresWeek() + ","+g.driver.finalYear() );
						if (this.checkExpiry(g))
								System.out.print("\tLICENSE EXPIRED!");

						if (this.checkLate(g))
							System.out.print("\tON LATE DUTY!");
						
						System.out.println();
						String inter = findIntermediate(intermediate,g);
						
						//Now check custom constraints
						this.checkCustomConstraints(g, inter);
						
//						System.out.println("\t"+inter);
					}
				}
			}
		}

		
		
//		System.out.println("Plan by week / day ");
//		System.out.println("Week , Day , Driver ID ,Group,Duty,Expiry Week, Final Year" );
//		//Print by week
//		for (int week =0; week < ProblemParameters.WEEKS; week++) {
//			for (int day =0; day < 7; day ++) {
//				for (Gene g : chromosome) {
//					if ((g.slot.getWeek() == week) && (g.slot.getDay()==day)) {
//
//						System.out.print(week + "," +day +"," + g.driver.getID() +"," +g.driver.group().name() + "," +g.driver.getDuty(week)+","+g.driver.getExpiresWeek() + ","+g.driver.finalYear() );
//						if (g.driver.finalYear())
//							if(g.driver.getExpiresWeek() < week)
//								System.out.print(", LICENSE EXPIRED!");
//
//						if (g.driver.getDuty(week)==1)
//							System.out.print(", ON LATE DUTY!");
//						System.out.println();
//					}
//				}
//			}
//		}
//
//		System.out.println("Additional constraints:");
//		String[] intermediate = this.getIntermediate();
//
//		for (CustomConstraint cp: customConstraints) {
//			//Pattern pattern = Pattern.compile(cp.getRegex(), Pattern.CASE_INSENSITIVE);
//			System.out.print("'"+cp.getSource());
//			if (cp.mustAppear()) {
//				boolean found = false;
//				for (String i : intermediate) {
//					Matcher matcher = cp.getPattern().matcher(i);
//					if (matcher.find()) 
//						found = true;
//				}
//				if (found) 
//					System.out.println( "' has been met." );
//				else
//					System.out.println( "' has not been met." );
//			}else {
//				boolean found = false;
//				for (String i : intermediate) {
//					Matcher matcher = cp.getPattern().matcher(i);
//					if (matcher.find()) 
//						found = true;
//				}
//
//				if (!found) 
//					System.out.println("' has been met." );
//				else
//					System.out.println("' has not been met." );
//
//				
//			}
//
//		}
	}

	private String[] intermediateBuffer;

	public String[] getIntermediate() {
		//Print by week
		int c=0;
		for (Gene g : chromosome) {
			String w =""+ g.slot.getWeek();
			if (w.length()<2) w ="0"+w;

			String xw = ""+g.driver.getExpiresWeek();
			if (xw.length()<2) xw ="0"+xw;
			int fy=0;
			if (g.driver.finalYear()) fy=1;

			//intermediateBuffer[c] =  (":WK:"+w + ":DY:" +g.slot.getDay() +":ID:" + g.driver.getID() +":GR:" +g.driver.group().name() + ":DT:" +g.driver.getDuty(g.slot.getWeek())+":XW:"+xw + ":FY:"+fy );	
			intermediateBuffer[c] =  (
					":ID:" + g.driver.getID() +
					":GR:" +g.driver.group().name() + 
					":WK:"+w + 
					":DY:" +g.slot.getDay() +
					":DT:" +g.driver.getDuty(g.slot.getWeek())+
					":XW:"+xw + 
					":FY:"+fy );	

			c++;
		}
		//		String buffer = "";
		//		for (String s : intermediateBuffer) {
		//			//			buffer = buffer + s;
		//		}
		return intermediateBuffer;
	}


	public Individual (Individual other) {
		initParticipants();
		//Copy constructor
		this.chromosome = new ArrayList<Gene>();
		for (Gene og : other.chromosome) {
			Gene ng = new Gene();
			ng.driver = og.driver;
			ng.slot = og.slot;
			this.chromosome.add(ng);
		}

		this.free = new ArrayList<TrainingSlot>();
		for (TrainingSlot s : other.free)
			this.free.add(s);

		modified = true;
		intermediateBuffer = new String[chromosome.size()];
	}

	private void verify() throws Exception {
		/* Verify that the chromsome contains a valid solution */
		ArrayList<TrainingSlot> slots = SlotFactory.getSlotSet();


		for (Gene g : chromosome) {
			if (g.driver == null)
				throw new Exception("Null driver in gene");

			if (g.slot == null)
				throw new Exception("Null slot in gene");


			if (slots.contains(g.slot)) {
				slots.remove(slots.indexOf(g.slot));
			}else {
				throw new Exception("Duplicated slot ");
			}
		}

		for (TrainingSlot s : free) {
			if (slots.contains(s)) {
				slots.remove(slots.indexOf(s));
			}else {
				throw new Exception("Duplicate unallocated slot");
			}
		}
		if (slots.size() !=0) {
			throw new Exception("Extra slots left");
		}
	}
	public String stats() {
		return  "fit," +fitness +",lates,"+lates +",expired,"+expired +",imbalance,"+groupImbalanced +",low," +lowConstraintViolations +",med," +mediumConstraintViolations+",high," +highConstraintViolations;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-02-20 23:03:22.372
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-02-20 23:03:22.372
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-20 23:03:22.388
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Random;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Individual {
	private Random rnd = new Random();
	private ArrayList<Gene> chromosome;
	private ArrayList<TrainingSlot> free;
	private boolean modified = true;
	private int fitness;
	private int expired=0;
	private int lates=0;
	private int groupImbalanced=0;
	private int lowConstraintViolations=0;
	private int mediumConstraintViolations=0;
	private int highConstraintViolations=0;

	private int[][][]participants = new int[ProblemParameters.WEEKS][][];
	private static ArrayList<CustomConstraint> customConstraints;


	private static int[] targets=null;//Targets from each group

	//	public static void loadConstraints() {
	//		//		constraintsPresent = new ArrayList<String>();
	//		//		constraintsNotPresent = new ArrayList<String>();
	//		customConstraints = new ArrayList<CustomConstraint>();
	//		String fileName = "./constraints.txt";
	//
	//
	//		try (BufferedReader br = new BufferedReader(new FileReader(fileName))) {
	//			String line;
	//			int lineNo=1;
	//			while ((line = br.readLine()) != null) {
	//				//process line
	//				CustomConstraint cp=null;
	//				try {
	//					cp = Parser.parse(line);
	//
	//				}catch(Exception e) {
	//					System.out.println("Error reading constraints \nLine no " + lineNo +" "+ e.getMessage());
	//					System.exit(-1);
	//				}
	//				if (cp != null) {
	//					customConstraints.add(cp);
	//					//					char ch = line.charAt(0);
	//					//					line = line.substring(1);
	//					//					if (ch=='+') {
	//					//						constraintsPresent.add(line);
	//					//					}
	//					//					if (ch=='-') {
	//					//						constraintsNotPresent.add(line);
	//					//					}
	//				}
	//				lineNo++;
	//
	//			}
	//		} catch (FileNotFoundException e) {
	//			e.printStackTrace();
	//		} catch (IOException e) {
	//			e.printStackTrace();
	//		}
	//
	//	}
	public static void setConstraints(ArrayList<String> text) {
		//		constraintsPresent = new ArrayList<String>();
		//		constraintsNotPresent = new ArrayList<String>();
		customConstraints = new ArrayList<CustomConstraint>();


		int lineNo=1;
		for (String line : text) {
			//process line
			CustomConstraint cp=null;
			try {
				cp = Parser.parse(line);

			}catch(Exception e) {
				System.out.println("Error reading constraints \nLine no " + lineNo +" "+ e.getMessage());
				System.exit(-1);
			}
			if (cp != null) {
				customConstraints.add(cp);
			}
			lineNo++;
		}
	}
	public Individual() {
		init();
		if (targets==null) {
			int tDrivers = DriverFactory.getDriverList().size();
			targets = new int[Group.values().length];
			for(Group g :Group.values()) {
				int count=0;
				for (Driver d : DriverFactory.getDriverList()) {
					if (d.group()==g)					
						count++;
				}
				float t =  (count/(float)tDrivers)*ProblemParameters.TRAINING_PLACES;
				targets[g.ordinal()] = Math.round(t);
				targets[g.ordinal()]++;
				//				System.out.println("Target " + g.name() + " "+targets[g.ordinal()]);
			}

		}

	}
	public int fitness() {
		//		try {
		//			this.verify();
		//		} catch (Exception e) {
		//			// TODO Auto-generated catch block
		//			e.printStackTrace();
		//			System.exit(-1);
		//		}

		if (modified) {
			ProblemParameters.EVALS++;
			modified = false;
			fitness =0;
			lates=0;
			expired=0;
			groupImbalanced=0;
			lowConstraintViolations=0;
			mediumConstraintViolations=0;
			highConstraintViolations=0;
			//Count participants from each group.
			for (int x=0;x < participants.length; x++ ) {
				for (int d=0; d < 7; d++) {
					for (int g =0; g < Group.values().length; g++ )
						participants[x][d][g] = 0;
				}
			}


			for (Gene g : chromosome) {
				
				if (checkLate(g)) {
					fitness = fitness + ProblemParameters.PENALTY_LATE_SHIFT;
					lates++;
				}
				//Check for training after expiry
				if (checkExpiry(g)) {
					fitness = fitness + ProblemParameters.PENALTY_EXPIRED_LICENSE;
					expired++;
				}else {
				//Encourage training as far before expiry as possible
					(g.slot.getWeek()/g.driver.getExpiresWeek())*ProblemParameters.PENALTY_ADVANCE_FINAL_WEEK
				}
				//Log participation
				participants[g.slot.getWeek()][g.slot.getDay()][g.driver.group().ordinal()]++;

			}
			//Check for imbalance in participants
			checkImbalance();
			checkCustomConstraints();
		}
		return fitness;
	}
	
	private void checkCustomConstraints(Gene g, String intermediate) {
		for (CustomConstraint cp : customConstraints) {
			if (!cp.mustAppear()) {
				int found = 0;
					//Matcher matcher = pattern.matcher(i);
					Matcher matcher = cp.getPattern().matcher(intermediate);
					if (matcher.find()) {
						found ++;
					}
				

				int p=1;
				if (found > 0)
					System.out.println("\t Violation " + cp.getSource() );
//				if (cp.getPriority() == ConstraintPriority.high) {
//					p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
//					highConstraintViolations  = highConstraintViolations + found;
//				}
//				if (cp.getPriority() == ConstraintPriority.medium) {
//					p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
//					mediumConstraintViolations  = mediumConstraintViolations + found;
//				}
//				if (cp.getPriority() == ConstraintPriority.low) {
//					p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
//					lowConstraintViolations  = lowConstraintViolations + found;
//				}


			}else {
				boolean found = false;
					Matcher matcher = cp.getPattern().matcher(intermediate);
					if (matcher.find()) {
						found = true;
						break;
					}
				
				if (!found) {
					int p=1;
					System.out.println("\t Violation " + cp.getSource() );
//					if (cp.getPriority() == ConstraintPriority.high) {
//						p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
//						highConstraintViolations ++;
//					}
//					if (cp.getPriority() == ConstraintPriority.medium) {
//						p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
//						mediumConstraintViolations ++;
//					}
//					if (cp.getPriority() == ConstraintPriority.low) {
//						p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
//						lowConstraintViolations ++;
//					}

				}
			}
		}
	}
	private void checkCustomConstraints() {
		String[] intermediate = this.getIntermediate();
		for (CustomConstraint cp : customConstraints) {
			if (!cp.mustAppear()) {
				int found = 0;
				for (String i : intermediate) {
					//Matcher matcher = pattern.matcher(i);
					Matcher matcher = cp.getPattern().matcher(i);
					if (matcher.find()) {
						found ++;
					}
				}

				int p=1;
				if (cp.getPriority() == ConstraintPriority.high) {
					p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
					highConstraintViolations  = highConstraintViolations + found;
				}
				if (cp.getPriority() == ConstraintPriority.medium) {
					p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
					mediumConstraintViolations  = mediumConstraintViolations + found;
				}
				if (cp.getPriority() == ConstraintPriority.low) {
					p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
					lowConstraintViolations  = lowConstraintViolations + found;
				}

				fitness = fitness + (found *p);

			}else {
				boolean found = false;
				for (String i : intermediate) {
					Matcher matcher = cp.getPattern().matcher(i);
					if (matcher.find()) {
						found = true;
						break;
					}
				}
				if (!found) {
					int p=1;
					if (cp.getPriority() == ConstraintPriority.high) {
						p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
						highConstraintViolations ++;
					}
					if (cp.getPriority() == ConstraintPriority.medium) {
						p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
						mediumConstraintViolations ++;
					}
					if (cp.getPriority() == ConstraintPriority.low) {
						p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
						lowConstraintViolations ++;
					}

					fitness = fitness + p;
				}
			}
		}
	}
	private void checkImbalance() {
		for (int[][] p : participants) {
			for (int d=0; d < 7; d++) {
				for (Group g : Group.values()) {
					if (p[d][g.ordinal()]>targets[g.ordinal()]) {
						int over = p[d][g.ordinal()]-targets[g.ordinal()];
						groupImbalanced=groupImbalanced+over;
						fitness = fitness +(over *ProblemParameters.PENALTY_GROUP_IMBALANCE);
					}
				}
			}
		}
	}

	private boolean checkLate(Gene g) {
		if (g.driver.getDuty(g.slot.getWeek())==1) {
			return true;
		}
		return false;
	}

	public boolean checkExpiry(Gene g) {
		int week = g.slot.getWeek();
		if (g.driver.finalYear()) {
			if(week >  g.driver.getExpiresWeek()) {
				return true;
			}
		}
		return false;

	}

	public void initParticipants() {
		participants = new int[ProblemParameters.WEEKS][][];
		for (int x=0;x < participants.length; x++ ) {
			participants[x] = new int[7][];
			for (int d=0; d < 7; d++) {
				participants[x][d] = new int[Group.values().length];
			}
		}

	}
	public void init() {

		modified = true;
		initParticipants();
		//Random init
		free = new ArrayList<TrainingSlot>();
		chromosome = new ArrayList<Gene>();

		try {
			free.addAll(SlotFactory.getSlotSet() ) ;

			//Now create genes
			for (Driver d : DriverFactory.getDriverList()) {
				Gene g = new Gene();
				g.driver = d;
				g.slot = getRndUnalloc(d);
				chromosome.add(g);
			}

		} catch (Exception e) {
			e.printStackTrace();
		}
		intermediateBuffer = new String[chromosome.size()];
	}

	private TrainingSlot getRndUnalloc(Driver d) {
		//Bias towards early shift & unexpired

		int idx = rnd.nextInt(free.size());

		for (int tries =0; tries <=150; tries++) {
			TrainingSlot s = free.get(idx);
			int week = s.getWeek();
			if (d.finalYear()) {
				if (week <= d.getExpiresWeek())
					break;
			}else {

				int duty = d.getDuty(week);
				if (duty==2) {
					break;
				}
			}
			idx = rnd.nextInt(free.size());
		}
		return free.remove(idx);
	}

	public void mutate() {
		modified = true;
		//mutate
		if (rnd.nextBoolean()) {
			//Sawp
			Gene g1 = chromosome.get(rnd.nextInt(chromosome.size()));


			//Bias towards slot issues
			if (rnd.nextBoolean()) {
				int t=0;
				while ((g1.driver.getDuty(g1.slot.getWeek())==1) &&( t <11)){
					g1 = chromosome.get(rnd.nextInt(chromosome.size()));
					t++;
				}
			}

			Gene g2 = chromosome.get(rnd.nextInt(chromosome.size()));
			TrainingSlot tmp = g1.slot;
			g1.slot = g2.slot;
			g2.slot = tmp;
		}else {
			//Swap to unalloc
			Gene g1 = chromosome.get(rnd.nextInt(chromosome.size()));
			TrainingSlot tmp = free.remove(rnd.nextInt(free.size()));
			free.add(g1.slot);
			g1.slot = tmp;
		}
	}



	public Individual(Individual p1, Individual p2) throws Exception {
		initParticipants();
		modified = true;
		//Crossover constructor
		free = new ArrayList<TrainingSlot>();
		free.addAll(SlotFactory.getSlotSet()) ;
		chromosome = new ArrayList<Gene>();

		for (int count =0; count <  p1.chromosome.size(); count ++) {
			Gene g  = new Gene();
			Gene p1g = p1.chromosome.get(count);
			Gene p2g = p2.chromosome.get(count);
			g.driver = p1g.driver;
			if (rnd.nextBoolean()) {
				//Add p1
				TrainingSlot s = p1g.slot;
				if (free.contains(s)) {
					g.slot = s;
					free.remove(s);
				}else {
					s = p2g.slot;
					if (free.contains(s)) {
						g.slot = s;
						free.remove(s);
					}else {
						s = free.remove(0);
						g.slot=s;
					}
				}
			}else{
				//Add p2
				TrainingSlot s = p2g.slot;
				if (free.contains(s)) {
					g.slot = s;
					free.remove(s);
				}else {
					s = p1g.slot;
					if (free.contains(s)) {
						g.slot = s;
						free.remove(s);
					}else {
						s = free.remove(0);
						g.slot=s;
					}
				}
			}
			chromosome.add(g);
		}
		intermediateBuffer = new String[chromosome.size()];
	}

	public void printSummary() {
		if (modified) {
			this.fitness();
		};
		//...
		System.out.println("CPC Plan");
		System.out.println("Issues :");
		System.out.println("CPC on lates shift: \t" +lates); 
		System.out.println("License expired before training: \t"+expired);
		System.out.println("Imbalanced group places: \t"+groupImbalanced);
		System.out.println("Low Constraint violations: \t"+lowConstraintViolations);
		System.out.println("Medium Constraint violations: \t"+mediumConstraintViolations);
		System.out.println("High Constraint violations: \t"+highConstraintViolations);

	}

	public String findIntermediate(String[] intermediate, Gene g) {
		String drvId = g.driver.getID();
		for (String s : intermediate) {
			if (s.contains(drvId))
				return s;
		}
		return null;
	}
	public void printSol() {
		
		String[] intermediate = this.getIntermediate();
		
		System.out.println("Plan by week / day ");
		System.out.println("Week , Day , Driver ID ,Group,Duty,Expiry Week, Final Year" );
		//Print by week
		for (int week =0; week < ProblemParameters.WEEKS; week++) {
			for (int day =0; day < 7; day ++) {
				for (Gene g : chromosome) {
					if ((g.slot.getWeek() == week) && (g.slot.getDay()==day)) {

						System.out.print(week + "," +day +"," + g.driver.getID() +"," +g.driver.group().name() + "," +g.driver.getDuty(week)+","+g.driver.getExpiresWeek() + ","+g.driver.finalYear() );
						if (this.checkExpiry(g))
								System.out.print("\tLICENSE EXPIRED!");

						if (this.checkLate(g))
							System.out.print("\tON LATE DUTY!");
						
						System.out.println();
						String inter = findIntermediate(intermediate,g);
						
						//Now check custom constraints
						this.checkCustomConstraints(g, inter);
						
//						System.out.println("\t"+inter);
					}
				}
			}
		}

		
		
//		System.out.println("Plan by week / day ");
//		System.out.println("Week , Day , Driver ID ,Group,Duty,Expiry Week, Final Year" );
//		//Print by week
//		for (int week =0; week < ProblemParameters.WEEKS; week++) {
//			for (int day =0; day < 7; day ++) {
//				for (Gene g : chromosome) {
//					if ((g.slot.getWeek() == week) && (g.slot.getDay()==day)) {
//
//						System.out.print(week + "," +day +"," + g.driver.getID() +"," +g.driver.group().name() + "," +g.driver.getDuty(week)+","+g.driver.getExpiresWeek() + ","+g.driver.finalYear() );
//						if (g.driver.finalYear())
//							if(g.driver.getExpiresWeek() < week)
//								System.out.print(", LICENSE EXPIRED!");
//
//						if (g.driver.getDuty(week)==1)
//							System.out.print(", ON LATE DUTY!");
//						System.out.println();
//					}
//				}
//			}
//		}
//
//		System.out.println("Additional constraints:");
//		String[] intermediate = this.getIntermediate();
//
//		for (CustomConstraint cp: customConstraints) {
//			//Pattern pattern = Pattern.compile(cp.getRegex(), Pattern.CASE_INSENSITIVE);
//			System.out.print("'"+cp.getSource());
//			if (cp.mustAppear()) {
//				boolean found = false;
//				for (String i : intermediate) {
//					Matcher matcher = cp.getPattern().matcher(i);
//					if (matcher.find()) 
//						found = true;
//				}
//				if (found) 
//					System.out.println( "' has been met." );
//				else
//					System.out.println( "' has not been met." );
//			}else {
//				boolean found = false;
//				for (String i : intermediate) {
//					Matcher matcher = cp.getPattern().matcher(i);
//					if (matcher.find()) 
//						found = true;
//				}
//
//				if (!found) 
//					System.out.println("' has been met." );
//				else
//					System.out.println("' has not been met." );
//
//				
//			}
//
//		}
	}

	private String[] intermediateBuffer;

	public String[] getIntermediate() {
		//Print by week
		int c=0;
		for (Gene g : chromosome) {
			String w =""+ g.slot.getWeek();
			if (w.length()<2) w ="0"+w;

			String xw = ""+g.driver.getExpiresWeek();
			if (xw.length()<2) xw ="0"+xw;
			int fy=0;
			if (g.driver.finalYear()) fy=1;

			//intermediateBuffer[c] =  (":WK:"+w + ":DY:" +g.slot.getDay() +":ID:" + g.driver.getID() +":GR:" +g.driver.group().name() + ":DT:" +g.driver.getDuty(g.slot.getWeek())+":XW:"+xw + ":FY:"+fy );	
			intermediateBuffer[c] =  (
					":ID:" + g.driver.getID() +
					":GR:" +g.driver.group().name() + 
					":WK:"+w + 
					":DY:" +g.slot.getDay() +
					":DT:" +g.driver.getDuty(g.slot.getWeek())+
					":XW:"+xw + 
					":FY:"+fy );	

			c++;
		}
		//		String buffer = "";
		//		for (String s : intermediateBuffer) {
		//			//			buffer = buffer + s;
		//		}
		return intermediateBuffer;
	}


	public Individual (Individual other) {
		initParticipants();
		//Copy constructor
		this.chromosome = new ArrayList<Gene>();
		for (Gene og : other.chromosome) {
			Gene ng = new Gene();
			ng.driver = og.driver;
			ng.slot = og.slot;
			this.chromosome.add(ng);
		}

		this.free = new ArrayList<TrainingSlot>();
		for (TrainingSlot s : other.free)
			this.free.add(s);

		modified = true;
		intermediateBuffer = new String[chromosome.size()];
	}

	private void verify() throws Exception {
		/* Verify that the chromsome contains a valid solution */
		ArrayList<TrainingSlot> slots = SlotFactory.getSlotSet();


		for (Gene g : chromosome) {
			if (g.driver == null)
				throw new Exception("Null driver in gene");

			if (g.slot == null)
				throw new Exception("Null slot in gene");


			if (slots.contains(g.slot)) {
				slots.remove(slots.indexOf(g.slot));
			}else {
				throw new Exception("Duplicated slot ");
			}
		}

		for (TrainingSlot s : free) {
			if (slots.contains(s)) {
				slots.remove(slots.indexOf(s));
			}else {
				throw new Exception("Duplicate unallocated slot");
			}
		}
		if (slots.size() !=0) {
			throw new Exception("Extra slots left");
		}
	}
	public String stats() {
		return  "fit," +fitness +",lates,"+lates +",expired,"+expired +",imbalance,"+groupImbalanced +",low," +lowConstraintViolations +",med," +mediumConstraintViolations+",high," +highConstraintViolations;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-02-20 23:03:22.389
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-02-20 23:03:22.389
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-20 23:03:30.014
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Random;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Individual {
	private Random rnd = new Random();
	private ArrayList<Gene> chromosome;
	private ArrayList<TrainingSlot> free;
	private boolean modified = true;
	private int fitness;
	private int expired=0;
	private int lates=0;
	private int groupImbalanced=0;
	private int lowConstraintViolations=0;
	private int mediumConstraintViolations=0;
	private int highConstraintViolations=0;

	private int[][][]participants = new int[ProblemParameters.WEEKS][][];
	private static ArrayList<CustomConstraint> customConstraints;


	private static int[] targets=null;//Targets from each group

	//	public static void loadConstraints() {
	//		//		constraintsPresent = new ArrayList<String>();
	//		//		constraintsNotPresent = new ArrayList<String>();
	//		customConstraints = new ArrayList<CustomConstraint>();
	//		String fileName = "./constraints.txt";
	//
	//
	//		try (BufferedReader br = new BufferedReader(new FileReader(fileName))) {
	//			String line;
	//			int lineNo=1;
	//			while ((line = br.readLine()) != null) {
	//				//process line
	//				CustomConstraint cp=null;
	//				try {
	//					cp = Parser.parse(line);
	//
	//				}catch(Exception e) {
	//					System.out.println("Error reading constraints \nLine no " + lineNo +" "+ e.getMessage());
	//					System.exit(-1);
	//				}
	//				if (cp != null) {
	//					customConstraints.add(cp);
	//					//					char ch = line.charAt(0);
	//					//					line = line.substring(1);
	//					//					if (ch=='+') {
	//					//						constraintsPresent.add(line);
	//					//					}
	//					//					if (ch=='-') {
	//					//						constraintsNotPresent.add(line);
	//					//					}
	//				}
	//				lineNo++;
	//
	//			}
	//		} catch (FileNotFoundException e) {
	//			e.printStackTrace();
	//		} catch (IOException e) {
	//			e.printStackTrace();
	//		}
	//
	//	}
	public static void setConstraints(ArrayList<String> text) {
		//		constraintsPresent = new ArrayList<String>();
		//		constraintsNotPresent = new ArrayList<String>();
		customConstraints = new ArrayList<CustomConstraint>();


		int lineNo=1;
		for (String line : text) {
			//process line
			CustomConstraint cp=null;
			try {
				cp = Parser.parse(line);

			}catch(Exception e) {
				System.out.println("Error reading constraints \nLine no " + lineNo +" "+ e.getMessage());
				System.exit(-1);
			}
			if (cp != null) {
				customConstraints.add(cp);
			}
			lineNo++;
		}
	}
	public Individual() {
		init();
		if (targets==null) {
			int tDrivers = DriverFactory.getDriverList().size();
			targets = new int[Group.values().length];
			for(Group g :Group.values()) {
				int count=0;
				for (Driver d : DriverFactory.getDriverList()) {
					if (d.group()==g)					
						count++;
				}
				float t =  (count/(float)tDrivers)*ProblemParameters.TRAINING_PLACES;
				targets[g.ordinal()] = Math.round(t);
				targets[g.ordinal()]++;
				//				System.out.println("Target " + g.name() + " "+targets[g.ordinal()]);
			}

		}

	}
	public int fitness() {
		//		try {
		//			this.verify();
		//		} catch (Exception e) {
		//			// TODO Auto-generated catch block
		//			e.printStackTrace();
		//			System.exit(-1);
		//		}

		if (modified) {
			ProblemParameters.EVALS++;
			modified = false;
			fitness =0;
			lates=0;
			expired=0;
			groupImbalanced=0;
			lowConstraintViolations=0;
			mediumConstraintViolations=0;
			highConstraintViolations=0;
			//Count participants from each group.
			for (int x=0;x < participants.length; x++ ) {
				for (int d=0; d < 7; d++) {
					for (int g =0; g < Group.values().length; g++ )
						participants[x][d][g] = 0;
				}
			}


			for (Gene g : chromosome) {
				
				if (checkLate(g)) {
					fitness = fitness + ProblemParameters.PENALTY_LATE_SHIFT;
					lates++;
				}
				//Check for training after expiry
				if (checkExpiry(g)) {
					fitness = fitness + ProblemParameters.PENALTY_EXPIRED_LICENSE;
					expired++;
				}else {
				//Encourage training as far before expiry as possible
					(g.slot.getWeek()/g.driver.getExpiresWeek())*ProblemParameters.PENALTY_ADVANCE_FINAL_WEEK
				}
				//Log participation
				participants[g.slot.getWeek()][g.slot.getDay()][g.driver.group().ordinal()]++;

			}
			//Check for imbalance in participants
			checkImbalance();
			checkCustomConstraints();
		}
		return fitness;
	}
	
	private void checkCustomConstraints(Gene g, String intermediate) {
		for (CustomConstraint cp : customConstraints) {
			if (!cp.mustAppear()) {
				int found = 0;
					//Matcher matcher = pattern.matcher(i);
					Matcher matcher = cp.getPattern().matcher(intermediate);
					if (matcher.find()) {
						found ++;
					}
				

				int p=1;
				if (found > 0)
					System.out.println("\t Violation " + cp.getSource() );
//				if (cp.getPriority() == ConstraintPriority.high) {
//					p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
//					highConstraintViolations  = highConstraintViolations + found;
//				}
//				if (cp.getPriority() == ConstraintPriority.medium) {
//					p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
//					mediumConstraintViolations  = mediumConstraintViolations + found;
//				}
//				if (cp.getPriority() == ConstraintPriority.low) {
//					p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
//					lowConstraintViolations  = lowConstraintViolations + found;
//				}


			}else {
				boolean found = false;
					Matcher matcher = cp.getPattern().matcher(intermediate);
					if (matcher.find()) {
						found = true;
						break;
					}
				
				if (!found) {
					int p=1;
					System.out.println("\t Violation " + cp.getSource() );
//					if (cp.getPriority() == ConstraintPriority.high) {
//						p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
//						highConstraintViolations ++;
//					}
//					if (cp.getPriority() == ConstraintPriority.medium) {
//						p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
//						mediumConstraintViolations ++;
//					}
//					if (cp.getPriority() == ConstraintPriority.low) {
//						p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
//						lowConstraintViolations ++;
//					}

				}
			}
		}
	}
	private void checkCustomConstraints() {
		String[] intermediate = this.getIntermediate();
		for (CustomConstraint cp : customConstraints) {
			if (!cp.mustAppear()) {
				int found = 0;
				for (String i : intermediate) {
					//Matcher matcher = pattern.matcher(i);
					Matcher matcher = cp.getPattern().matcher(i);
					if (matcher.find()) {
						found ++;
					}
				}

				int p=1;
				if (cp.getPriority() == ConstraintPriority.high) {
					p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
					highConstraintViolations  = highConstraintViolations + found;
				}
				if (cp.getPriority() == ConstraintPriority.medium) {
					p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
					mediumConstraintViolations  = mediumConstraintViolations + found;
				}
				if (cp.getPriority() == ConstraintPriority.low) {
					p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
					lowConstraintViolations  = lowConstraintViolations + found;
				}

				fitness = fitness + (found *p);

			}else {
				boolean found = false;
				for (String i : intermediate) {
					Matcher matcher = cp.getPattern().matcher(i);
					if (matcher.find()) {
						found = true;
						break;
					}
				}
				if (!found) {
					int p=1;
					if (cp.getPriority() == ConstraintPriority.high) {
						p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
						highConstraintViolations ++;
					}
					if (cp.getPriority() == ConstraintPriority.medium) {
						p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
						mediumConstraintViolations ++;
					}
					if (cp.getPriority() == ConstraintPriority.low) {
						p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
						lowConstraintViolations ++;
					}

					fitness = fitness + p;
				}
			}
		}
	}
	private void checkImbalance() {
		for (int[][] p : participants) {
			for (int d=0; d < 7; d++) {
				for (Group g : Group.values()) {
					if (p[d][g.ordinal()]>targets[g.ordinal()]) {
						int over = p[d][g.ordinal()]-targets[g.ordinal()];
						groupImbalanced=groupImbalanced+over;
						fitness = fitness +(over *ProblemParameters.PENALTY_GROUP_IMBALANCE);
					}
				}
			}
		}
	}

	private boolean checkLate(Gene g) {
		if (g.driver.getDuty(g.slot.getWeek())==1) {
			return true;
		}
		return false;
	}

	public boolean checkExpiry(Gene g) {
		int week = g.slot.getWeek();
		if (g.driver.finalYear()) {
			if(week >  g.driver.getExpiresWeek()) {
				return true;
			}
		}
		return false;

	}

	public void initParticipants() {
		participants = new int[ProblemParameters.WEEKS][][];
		for (int x=0;x < participants.length; x++ ) {
			participants[x] = new int[7][];
			for (int d=0; d < 7; d++) {
				participants[x][d] = new int[Group.values().length];
			}
		}

	}
	public void init() {

		modified = true;
		initParticipants();
		//Random init
		free = new ArrayList<TrainingSlot>();
		chromosome = new ArrayList<Gene>();

		try {
			free.addAll(SlotFactory.getSlotSet() ) ;

			//Now create genes
			for (Driver d : DriverFactory.getDriverList()) {
				Gene g = new Gene();
				g.driver = d;
				g.slot = getRndUnalloc(d);
				chromosome.add(g);
			}

		} catch (Exception e) {
			e.printStackTrace();
		}
		intermediateBuffer = new String[chromosome.size()];
	}

	private TrainingSlot getRndUnalloc(Driver d) {
		//Bias towards early shift & unexpired

		int idx = rnd.nextInt(free.size());

		for (int tries =0; tries <=150; tries++) {
			TrainingSlot s = free.get(idx);
			int week = s.getWeek();
			if (d.finalYear()) {
				if (week <= d.getExpiresWeek())
					break;
			}else {

				int duty = d.getDuty(week);
				if (duty==2) {
					break;
				}
			}
			idx = rnd.nextInt(free.size());
		}
		return free.remove(idx);
	}

	public void mutate() {
		modified = true;
		//mutate
		if (rnd.nextBoolean()) {
			//Sawp
			Gene g1 = chromosome.get(rnd.nextInt(chromosome.size()));


			//Bias towards slot issues
			if (rnd.nextBoolean()) {
				int t=0;
				while ((g1.driver.getDuty(g1.slot.getWeek())==1) &&( t <11)){
					g1 = chromosome.get(rnd.nextInt(chromosome.size()));
					t++;
				}
			}

			Gene g2 = chromosome.get(rnd.nextInt(chromosome.size()));
			TrainingSlot tmp = g1.slot;
			g1.slot = g2.slot;
			g2.slot = tmp;
		}else {
			//Swap to unalloc
			Gene g1 = chromosome.get(rnd.nextInt(chromosome.size()));
			TrainingSlot tmp = free.remove(rnd.nextInt(free.size()));
			free.add(g1.slot);
			g1.slot = tmp;
		}
	}



	public Individual(Individual p1, Individual p2) throws Exception {
		initParticipants();
		modified = true;
		//Crossover constructor
		free = new ArrayList<TrainingSlot>();
		free.addAll(SlotFactory.getSlotSet()) ;
		chromosome = new ArrayList<Gene>();

		for (int count =0; count <  p1.chromosome.size(); count ++) {
			Gene g  = new Gene();
			Gene p1g = p1.chromosome.get(count);
			Gene p2g = p2.chromosome.get(count);
			g.driver = p1g.driver;
			if (rnd.nextBoolean()) {
				//Add p1
				TrainingSlot s = p1g.slot;
				if (free.contains(s)) {
					g.slot = s;
					free.remove(s);
				}else {
					s = p2g.slot;
					if (free.contains(s)) {
						g.slot = s;
						free.remove(s);
					}else {
						s = free.remove(0);
						g.slot=s;
					}
				}
			}else{
				//Add p2
				TrainingSlot s = p2g.slot;
				if (free.contains(s)) {
					g.slot = s;
					free.remove(s);
				}else {
					s = p1g.slot;
					if (free.contains(s)) {
						g.slot = s;
						free.remove(s);
					}else {
						s = free.remove(0);
						g.slot=s;
					}
				}
			}
			chromosome.add(g);
		}
		intermediateBuffer = new String[chromosome.size()];
	}

	public void printSummary() {
		if (modified) {
			this.fitness();
		};
		//...
		System.out.println("CPC Plan");
		System.out.println("Issues :");
		System.out.println("CPC on lates shift: \t" +lates); 
		System.out.println("License expired before training: \t"+expired);
		System.out.println("Imbalanced group places: \t"+groupImbalanced);
		System.out.println("Low Constraint violations: \t"+lowConstraintViolations);
		System.out.println("Medium Constraint violations: \t"+mediumConstraintViolations);
		System.out.println("High Constraint violations: \t"+highConstraintViolations);

	}

	public String findIntermediate(String[] intermediate, Gene g) {
		String drvId = g.driver.getID();
		for (String s : intermediate) {
			if (s.contains(drvId))
				return s;
		}
		return null;
	}
	public void printSol() {
		
		String[] intermediate = this.getIntermediate();
		
		System.out.println("Plan by week / day ");
		System.out.println("Week , Day , Driver ID ,Group,Duty,Expiry Week, Final Year" );
		//Print by week
		for (int week =0; week < ProblemParameters.WEEKS; week++) {
			for (int day =0; day < 7; day ++) {
				for (Gene g : chromosome) {
					if ((g.slot.getWeek() == week) && (g.slot.getDay()==day)) {

						System.out.print(week + "," +day +"," + g.driver.getID() +"," +g.driver.group().name() + "," +g.driver.getDuty(week)+","+g.driver.getExpiresWeek() + ","+g.driver.finalYear() );
						if (this.checkExpiry(g))
								System.out.print("\tLICENSE EXPIRED!");

						if (this.checkLate(g))
							System.out.print("\tON LATE DUTY!");
						
						System.out.println();
						String inter = findIntermediate(intermediate,g);
						
						//Now check custom constraints
						this.checkCustomConstraints(g, inter);
						
//						System.out.println("\t"+inter);
					}
				}
			}
		}

		
		
//		System.out.println("Plan by week / day ");
//		System.out.println("Week , Day , Driver ID ,Group,Duty,Expiry Week, Final Year" );
//		//Print by week
//		for (int week =0; week < ProblemParameters.WEEKS; week++) {
//			for (int day =0; day < 7; day ++) {
//				for (Gene g : chromosome) {
//					if ((g.slot.getWeek() == week) && (g.slot.getDay()==day)) {
//
//						System.out.print(week + "," +day +"," + g.driver.getID() +"," +g.driver.group().name() + "," +g.driver.getDuty(week)+","+g.driver.getExpiresWeek() + ","+g.driver.finalYear() );
//						if (g.driver.finalYear())
//							if(g.driver.getExpiresWeek() < week)
//								System.out.print(", LICENSE EXPIRED!");
//
//						if (g.driver.getDuty(week)==1)
//							System.out.print(", ON LATE DUTY!");
//						System.out.println();
//					}
//				}
//			}
//		}
//
//		System.out.println("Additional constraints:");
//		String[] intermediate = this.getIntermediate();
//
//		for (CustomConstraint cp: customConstraints) {
//			//Pattern pattern = Pattern.compile(cp.getRegex(), Pattern.CASE_INSENSITIVE);
//			System.out.print("'"+cp.getSource());
//			if (cp.mustAppear()) {
//				boolean found = false;
//				for (String i : intermediate) {
//					Matcher matcher = cp.getPattern().matcher(i);
//					if (matcher.find()) 
//						found = true;
//				}
//				if (found) 
//					System.out.println( "' has been met." );
//				else
//					System.out.println( "' has not been met." );
//			}else {
//				boolean found = false;
//				for (String i : intermediate) {
//					Matcher matcher = cp.getPattern().matcher(i);
//					if (matcher.find()) 
//						found = true;
//				}
//
//				if (!found) 
//					System.out.println("' has been met." );
//				else
//					System.out.println("' has not been met." );
//
//				
//			}
//
//		}
	}

	private String[] intermediateBuffer;

	public String[] getIntermediate() {
		//Print by week
		int c=0;
		for (Gene g : chromosome) {
			String w =""+ g.slot.getWeek();
			if (w.length()<2) w ="0"+w;

			String xw = ""+g.driver.getExpiresWeek();
			if (xw.length()<2) xw ="0"+xw;
			int fy=0;
			if (g.driver.finalYear()) fy=1;

			//intermediateBuffer[c] =  (":WK:"+w + ":DY:" +g.slot.getDay() +":ID:" + g.driver.getID() +":GR:" +g.driver.group().name() + ":DT:" +g.driver.getDuty(g.slot.getWeek())+":XW:"+xw + ":FY:"+fy );	
			intermediateBuffer[c] =  (
					":ID:" + g.driver.getID() +
					":GR:" +g.driver.group().name() + 
					":WK:"+w + 
					":DY:" +g.slot.getDay() +
					":DT:" +g.driver.getDuty(g.slot.getWeek())+
					":XW:"+xw + 
					":FY:"+fy );	

			c++;
		}
		//		String buffer = "";
		//		for (String s : intermediateBuffer) {
		//			//			buffer = buffer + s;
		//		}
		return intermediateBuffer;
	}


	public Individual (Individual other) {
		initParticipants();
		//Copy constructor
		this.chromosome = new ArrayList<Gene>();
		for (Gene og : other.chromosome) {
			Gene ng = new Gene();
			ng.driver = og.driver;
			ng.slot = og.slot;
			this.chromosome.add(ng);
		}

		this.free = new ArrayList<TrainingSlot>();
		for (TrainingSlot s : other.free)
			this.free.add(s);

		modified = true;
		intermediateBuffer = new String[chromosome.size()];
	}

	private void verify() throws Exception {
		/* Verify that the chromsome contains a valid solution */
		ArrayList<TrainingSlot> slots = SlotFactory.getSlotSet();


		for (Gene g : chromosome) {
			if (g.driver == null)
				throw new Exception("Null driver in gene");

			if (g.slot == null)
				throw new Exception("Null slot in gene");


			if (slots.contains(g.slot)) {
				slots.remove(slots.indexOf(g.slot));
			}else {
				throw new Exception("Duplicated slot ");
			}
		}

		for (TrainingSlot s : free) {
			if (slots.contains(s)) {
				slots.remove(slots.indexOf(s));
			}else {
				throw new Exception("Duplicate unallocated slot");
			}
		}
		if (slots.size() !=0) {
			throw new Exception("Extra slots left");
		}
	}
	public String stats() {
		return  "fit," +fitness +",lates,"+lates +",expired,"+expired +",imbalance,"+groupImbalanced +",low," +lowConstraintViolations +",med," +mediumConstraintViolations+",high," +highConstraintViolations;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-02-20 23:03:30.015
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-02-20 23:03:30.015
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-20 23:03:30.333
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Random;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Individual {
	private Random rnd = new Random();
	private ArrayList<Gene> chromosome;
	private ArrayList<TrainingSlot> free;
	private boolean modified = true;
	private int fitness;
	private int expired=0;
	private int lates=0;
	private int groupImbalanced=0;
	private int lowConstraintViolations=0;
	private int mediumConstraintViolations=0;
	private int highConstraintViolations=0;

	private int[][][]participants = new int[ProblemParameters.WEEKS][][];
	private static ArrayList<CustomConstraint> customConstraints;


	private static int[] targets=null;//Targets from each group

	//	public static void loadConstraints() {
	//		//		constraintsPresent = new ArrayList<String>();
	//		//		constraintsNotPresent = new ArrayList<String>();
	//		customConstraints = new ArrayList<CustomConstraint>();
	//		String fileName = "./constraints.txt";
	//
	//
	//		try (BufferedReader br = new BufferedReader(new FileReader(fileName))) {
	//			String line;
	//			int lineNo=1;
	//			while ((line = br.readLine()) != null) {
	//				//process line
	//				CustomConstraint cp=null;
	//				try {
	//					cp = Parser.parse(line);
	//
	//				}catch(Exception e) {
	//					System.out.println("Error reading constraints \nLine no " + lineNo +" "+ e.getMessage());
	//					System.exit(-1);
	//				}
	//				if (cp != null) {
	//					customConstraints.add(cp);
	//					//					char ch = line.charAt(0);
	//					//					line = line.substring(1);
	//					//					if (ch=='+') {
	//					//						constraintsPresent.add(line);
	//					//					}
	//					//					if (ch=='-') {
	//					//						constraintsNotPresent.add(line);
	//					//					}
	//				}
	//				lineNo++;
	//
	//			}
	//		} catch (FileNotFoundException e) {
	//			e.printStackTrace();
	//		} catch (IOException e) {
	//			e.printStackTrace();
	//		}
	//
	//	}
	public static void setConstraints(ArrayList<String> text) {
		//		constraintsPresent = new ArrayList<String>();
		//		constraintsNotPresent = new ArrayList<String>();
		customConstraints = new ArrayList<CustomConstraint>();


		int lineNo=1;
		for (String line : text) {
			//process line
			CustomConstraint cp=null;
			try {
				cp = Parser.parse(line);

			}catch(Exception e) {
				System.out.println("Error reading constraints \nLine no " + lineNo +" "+ e.getMessage());
				System.exit(-1);
			}
			if (cp != null) {
				customConstraints.add(cp);
			}
			lineNo++;
		}
	}
	public Individual() {
		init();
		if (targets==null) {
			int tDrivers = DriverFactory.getDriverList().size();
			targets = new int[Group.values().length];
			for(Group g :Group.values()) {
				int count=0;
				for (Driver d : DriverFactory.getDriverList()) {
					if (d.group()==g)					
						count++;
				}
				float t =  (count/(float)tDrivers)*ProblemParameters.TRAINING_PLACES;
				targets[g.ordinal()] = Math.round(t);
				targets[g.ordinal()]++;
				//				System.out.println("Target " + g.name() + " "+targets[g.ordinal()]);
			}

		}

	}
	public int fitness() {
		//		try {
		//			this.verify();
		//		} catch (Exception e) {
		//			// TODO Auto-generated catch block
		//			e.printStackTrace();
		//			System.exit(-1);
		//		}

		if (modified) {
			ProblemParameters.EVALS++;
			modified = false;
			fitness =0;
			lates=0;
			expired=0;
			groupImbalanced=0;
			lowConstraintViolations=0;
			mediumConstraintViolations=0;
			highConstraintViolations=0;
			//Count participants from each group.
			for (int x=0;x < participants.length; x++ ) {
				for (int d=0; d < 7; d++) {
					for (int g =0; g < Group.values().length; g++ )
						participants[x][d][g] = 0;
				}
			}


			for (Gene g : chromosome) {
				
				if (checkLate(g)) {
					fitness = fitness + ProblemParameters.PENALTY_LATE_SHIFT;
					lates++;
				}
				//Check for training after expiry
				if (checkExpiry(g)) {
					fitness = fitness + ProblemParameters.PENALTY_EXPIRED_LICENSE;
					expired++;
				}else {
				//Encourage training as far before expiry as possible
					(g.slot.getWeek()/g.driver.getExpiresWeek())*ProblemParameters.PENALTY_ADVANCE_FINAL_WEEK
				}
				//Log participation
				participants[g.slot.getWeek()][g.slot.getDay()][g.driver.group().ordinal()]++;

			}
			//Check for imbalance in participants
			checkImbalance();
			checkCustomConstraints();
		}
		return fitness;
	}
	
	private void checkCustomConstraints(Gene g, String intermediate) {
		for (CustomConstraint cp : customConstraints) {
			if (!cp.mustAppear()) {
				int found = 0;
					//Matcher matcher = pattern.matcher(i);
					Matcher matcher = cp.getPattern().matcher(intermediate);
					if (matcher.find()) {
						found ++;
					}
				

				int p=1;
				if (found > 0)
					System.out.println("\t Violation " + cp.getSource() );
//				if (cp.getPriority() == ConstraintPriority.high) {
//					p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
//					highConstraintViolations  = highConstraintViolations + found;
//				}
//				if (cp.getPriority() == ConstraintPriority.medium) {
//					p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
//					mediumConstraintViolations  = mediumConstraintViolations + found;
//				}
//				if (cp.getPriority() == ConstraintPriority.low) {
//					p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
//					lowConstraintViolations  = lowConstraintViolations + found;
//				}


			}else {
				boolean found = false;
					Matcher matcher = cp.getPattern().matcher(intermediate);
					if (matcher.find()) {
						found = true;
						break;
					}
				
				if (!found) {
					int p=1;
					System.out.println("\t Violation " + cp.getSource() );
//					if (cp.getPriority() == ConstraintPriority.high) {
//						p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
//						highConstraintViolations ++;
//					}
//					if (cp.getPriority() == ConstraintPriority.medium) {
//						p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
//						mediumConstraintViolations ++;
//					}
//					if (cp.getPriority() == ConstraintPriority.low) {
//						p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
//						lowConstraintViolations ++;
//					}

				}
			}
		}
	}
	private void checkCustomConstraints() {
		String[] intermediate = this.getIntermediate();
		for (CustomConstraint cp : customConstraints) {
			if (!cp.mustAppear()) {
				int found = 0;
				for (String i : intermediate) {
					//Matcher matcher = pattern.matcher(i);
					Matcher matcher = cp.getPattern().matcher(i);
					if (matcher.find()) {
						found ++;
					}
				}

				int p=1;
				if (cp.getPriority() == ConstraintPriority.high) {
					p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
					highConstraintViolations  = highConstraintViolations + found;
				}
				if (cp.getPriority() == ConstraintPriority.medium) {
					p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
					mediumConstraintViolations  = mediumConstraintViolations + found;
				}
				if (cp.getPriority() == ConstraintPriority.low) {
					p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
					lowConstraintViolations  = lowConstraintViolations + found;
				}

				fitness = fitness + (found *p);

			}else {
				boolean found = false;
				for (String i : intermediate) {
					Matcher matcher = cp.getPattern().matcher(i);
					if (matcher.find()) {
						found = true;
						break;
					}
				}
				if (!found) {
					int p=1;
					if (cp.getPriority() == ConstraintPriority.high) {
						p = ProblemParameters.PENALTY_HIGH_CONSTRAINT_VIOLATION;
						highConstraintViolations ++;
					}
					if (cp.getPriority() == ConstraintPriority.medium) {
						p = ProblemParameters.PENALTY_MEDIUM_CONSTRAINT_VIOLATION;
						mediumConstraintViolations ++;
					}
					if (cp.getPriority() == ConstraintPriority.low) {
						p = ProblemParameters.PENALTY_LOW_CONSTRAINT_VIOLATION;
						lowConstraintViolations ++;
					}

					fitness = fitness + p;
				}
			}
		}
	}
	private void checkImbalance() {
		for (int[][] p : participants) {
			for (int d=0; d < 7; d++) {
				for (Group g : Group.values()) {
					if (p[d][g.ordinal()]>targets[g.ordinal()]) {
						int over = p[d][g.ordinal()]-targets[g.ordinal()];
						groupImbalanced=groupImbalanced+over;
						fitness = fitness +(over *ProblemParameters.PENALTY_GROUP_IMBALANCE);
					}
				}
			}
		}
	}

	private boolean checkLate(Gene g) {
		if (g.driver.getDuty(g.slot.getWeek())==1) {
			return true;
		}
		return false;
	}

	public boolean checkExpiry(Gene g) {
		int week = g.slot.getWeek();
		if (g.driver.finalYear()) {
			if(week >  g.driver.getExpiresWeek()) {
				return true;
			}
		}
		return false;

	}

	public void initParticipants() {
		participants = new int[ProblemParameters.WEEKS][][];
		for (int x=0;x < participants.length; x++ ) {
			participants[x] = new int[7][];
			for (int d=0; d < 7; d++) {
				participants[x][d] = new int[Group.values().length];
			}
		}

	}
	public void init() {

		modified = true;
		initParticipants();
		//Random init
		free = new ArrayList<TrainingSlot>();
		chromosome = new ArrayList<Gene>();

		try {
			free.addAll(SlotFactory.getSlotSet() ) ;

			//Now create genes
			for (Driver d : DriverFactory.getDriverList()) {
				Gene g = new Gene();
				g.driver = d;
				g.slot = getRndUnalloc(d);
				chromosome.add(g);
			}

		} catch (Exception e) {
			e.printStackTrace();
		}
		intermediateBuffer = new String[chromosome.size()];
	}

	private TrainingSlot getRndUnalloc(Driver d) {
		//Bias towards early shift & unexpired

		int idx = rnd.nextInt(free.size());

		for (int tries =0; tries <=150; tries++) {
			TrainingSlot s = free.get(idx);
			int week = s.getWeek();
			if (d.finalYear()) {
				if (week <= d.getExpiresWeek())
					break;
			}else {

				int duty = d.getDuty(week);
				if (duty==2) {
					break;
				}
			}
			idx = rnd.nextInt(free.size());
		}
		return free.remove(idx);
	}

	public void mutate() {
		modified = true;
		//mutate
		if (rnd.nextBoolean()) {
			//Sawp
			Gene g1 = chromosome.get(rnd.nextInt(chromosome.size()));


			//Bias towards slot issues
			if (rnd.nextBoolean()) {
				int t=0;
				while ((g1.driver.getDuty(g1.slot.getWeek())==1) &&( t <11)){
					g1 = chromosome.get(rnd.nextInt(chromosome.size()));
					t++;
				}
			}

			Gene g2 = chromosome.get(rnd.nextInt(chromosome.size()));
			TrainingSlot tmp = g1.slot;
			g1.slot = g2.slot;
			g2.slot = tmp;
		}else {
			//Swap to unalloc
			Gene g1 = chromosome.get(rnd.nextInt(chromosome.size()));
			TrainingSlot tmp = free.remove(rnd.nextInt(free.size()));
			free.add(g1.slot);
			g1.slot = tmp;
		}
	}



	public Individual(Individual p1, Individual p2) throws Exception {
		initParticipants();
		modified = true;
		//Crossover constructor
		free = new ArrayList<TrainingSlot>();
		free.addAll(SlotFactory.getSlotSet()) ;
		chromosome = new ArrayList<Gene>();

		for (int count =0; count <  p1.chromosome.size(); count ++) {
			Gene g  = new Gene();
			Gene p1g = p1.chromosome.get(count);
			Gene p2g = p2.chromosome.get(count);
			g.driver = p1g.driver;
			if (rnd.nextBoolean()) {
				//Add p1
				TrainingSlot s = p1g.slot;
				if (free.contains(s)) {
					g.slot = s;
					free.remove(s);
				}else {
					s = p2g.slot;
					if (free.contains(s)) {
						g.slot = s;
						free.remove(s);
					}else {
						s = free.remove(0);
						g.slot=s;
					}
				}
			}else{
				//Add p2
				TrainingSlot s = p2g.slot;
				if (free.contains(s)) {
					g.slot = s;
					free.remove(s);
				}else {
					s = p1g.slot;
					if (free.contains(s)) {
						g.slot = s;
						free.remove(s);
					}else {
						s = free.remove(0);
						g.slot=s;
					}
				}
			}
			chromosome.add(g);
		}
		intermediateBuffer = new String[chromosome.size()];
	}

	public void printSummary() {
		if (modified) {
			this.fitness();
		};
		//...
		System.out.println("CPC Plan");
		System.out.println("Issues :");
		System.out.println("CPC on lates shift: \t" +lates); 
		System.out.println("License expired before training: \t"+expired);
		System.out.println("Imbalanced group places: \t"+groupImbalanced);
		System.out.println("Low Constraint violations: \t"+lowConstraintViolations);
		System.out.println("Medium Constraint violations: \t"+mediumConstraintViolations);
		System.out.println("High Constraint violations: \t"+highConstraintViolations);

	}

	public String findIntermediate(String[] intermediate, Gene g) {
		String drvId = g.driver.getID();
		for (String s : intermediate) {
			if (s.contains(drvId))
				return s;
		}
		return null;
	}
	public void printSol() {
		
		String[] intermediate = this.getIntermediate();
		
		System.out.println("Plan by week / day ");
		System.out.println("Week , Day , Driver ID ,Group,Duty,Expiry Week, Final Year" );
		//Print by week
		for (int week =0; week < ProblemParameters.WEEKS; week++) {
			for (int day =0; day < 7; day ++) {
				for (Gene g : chromosome) {
					if ((g.slot.getWeek() == week) && (g.slot.getDay()==day)) {

						System.out.print(week + "," +day +"," + g.driver.getID() +"," +g.driver.group().name() + "," +g.driver.getDuty(week)+","+g.driver.getExpiresWeek() + ","+g.driver.finalYear() );
						if (this.checkExpiry(g))
								System.out.print("\tLICENSE EXPIRED!");

						if (this.checkLate(g))
							System.out.print("\tON LATE DUTY!");
						
						System.out.println();
						String inter = findIntermediate(intermediate,g);
						
						//Now check custom constraints
						this.checkCustomConstraints(g, inter);
						
//						System.out.println("\t"+inter);
					}
				}
			}
		}

		
		
//		System.out.println("Plan by week / day ");
//		System.out.println("Week , Day , Driver ID ,Group,Duty,Expiry Week, Final Year" );
//		//Print by week
//		for (int week =0; week < ProblemParameters.WEEKS; week++) {
//			for (int day =0; day < 7; day ++) {
//				for (Gene g : chromosome) {
//					if ((g.slot.getWeek() == week) && (g.slot.getDay()==day)) {
//
//						System.out.print(week + "," +day +"," + g.driver.getID() +"," +g.driver.group().name() + "," +g.driver.getDuty(week)+","+g.driver.getExpiresWeek() + ","+g.driver.finalYear() );
//						if (g.driver.finalYear())
//							if(g.driver.getExpiresWeek() < week)
//								System.out.print(", LICENSE EXPIRED!");
//
//						if (g.driver.getDuty(week)==1)
//							System.out.print(", ON LATE DUTY!");
//						System.out.println();
//					}
//				}
//			}
//		}
//
//		System.out.println("Additional constraints:");
//		String[] intermediate = this.getIntermediate();
//
//		for (CustomConstraint cp: customConstraints) {
//			//Pattern pattern = Pattern.compile(cp.getRegex(), Pattern.CASE_INSENSITIVE);
//			System.out.print("'"+cp.getSource());
//			if (cp.mustAppear()) {
//				boolean found = false;
//				for (String i : intermediate) {
//					Matcher matcher = cp.getPattern().matcher(i);
//					if (matcher.find()) 
//						found = true;
//				}
//				if (found) 
//					System.out.println( "' has been met." );
//				else
//					System.out.println( "' has not been met." );
//			}else {
//				boolean found = false;
//				for (String i : intermediate) {
//					Matcher matcher = cp.getPattern().matcher(i);
//					if (matcher.find()) 
//						found = true;
//				}
//
//				if (!found) 
//					System.out.println("' has been met." );
//				else
//					System.out.println("' has not been met." );
//
//				
//			}
//
//		}
	}

	private String[] intermediateBuffer;

	public String[] getIntermediate() {
		//Print by week
		int c=0;
		for (Gene g : chromosome) {
			String w =""+ g.slot.getWeek();
			if (w.length()<2) w ="0"+w;

			String xw = ""+g.driver.getExpiresWeek();
			if (xw.length()<2) xw ="0"+xw;
			int fy=0;
			if (g.driver.finalYear()) fy=1;

			//intermediateBuffer[c] =  (":WK:"+w + ":DY:" +g.slot.getDay() +":ID:" + g.driver.getID() +":GR:" +g.driver.group().name() + ":DT:" +g.driver.getDuty(g.slot.getWeek())+":XW:"+xw + ":FY:"+fy );	
			intermediateBuffer[c] =  (
					":ID:" + g.driver.getID() +
					":GR:" +g.driver.group().name() + 
					":WK:"+w + 
					":DY:" +g.slot.getDay() +
					":DT:" +g.driver.getDuty(g.slot.getWeek())+
					":XW:"+xw + 
					":FY:"+fy );	

			c++;
		}
		//		String buffer = "";
		//		for (String s : intermediateBuffer) {
		//			//			buffer = buffer + s;
		//		}
		return intermediateBuffer;
	}


	public Individual (Individual other) {
		initParticipants();
		//Copy constructor
		this.chromosome = new ArrayList<Gene>();
		for (Gene og : other.chromosome) {
			Gene ng = new Gene();
			ng.driver = og.driver;
			ng.slot = og.slot;
			this.chromosome.add(ng);
		}

		this.free = new ArrayList<TrainingSlot>();
		for (TrainingSlot s : other.free)
			this.free.add(s);

		modified = true;
		intermediateBuffer = new String[chromosome.size()];
	}

	private void verify() throws Exception {
		/* Verify that the chromsome contains a valid solution */
		ArrayList<TrainingSlot> slots = SlotFactory.getSlotSet();


		for (Gene g : chromosome) {
			if (g.driver == null)
				throw new Exception("Null driver in gene");

			if (g.slot == null)
				throw new Exception("Null slot in gene");


			if (slots.contains(g.slot)) {
				slots.remove(slots.indexOf(g.slot));
			}else {
				throw new Exception("Duplicated slot ");
			}
		}

		for (TrainingSlot s : free) {
			if (slots.contains(s)) {
				slots.remove(slots.indexOf(s));
			}else {
				throw new Exception("Duplicate unallocated slot");
			}
		}
		if (slots.size() !=0) {
			throw new Exception("Extra slots left");
		}
	}
	public String stats() {
		return  "fit," +fitness +",lates,"+lates +",expired,"+expired +",imbalance,"+groupImbalanced +",low," +lowConstraintViolations +",med," +mediumConstraintViolations+",high," +highConstraintViolations;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-02-20 23:03:30.334
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-02-20 23:03:30.335
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2023-03-03 16:34:56.095 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=aarch64, WS=cocoa, NL=en_GB
Framework arguments:  -product org.eclipse.epp.package.jee.product -keyring /Users/neilurquhart/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch aarch64 -product org.eclipse.epp.package.jee.product -keyring /Users/neilurquhart/.eclipse_keyring

!ENTRY org.eclipse.core.resources 2 10035 2023-03-03 16:34:59.398
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2023-03-03 16:35:00.556
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-03 16:35:00.556
!MESSAGE A conflict occurred for COMMAND+SHIFT+T:
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-03 16:35:00.556
!MESSAGE A conflict occurred for ALT+COMMAND+R:
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
!SESSION 2023-04-21 11:53:01.084 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=aarch64, WS=cocoa, NL=en_GB
Framework arguments:  -product org.eclipse.epp.package.jee.product -keyring /Users/neilurquhart/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch aarch64 -product org.eclipse.epp.package.jee.product -keyring /Users/neilurquhart/.eclipse_keyring

!ENTRY org.eclipse.jface 2 0 2023-04-21 11:53:06.681
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-21 11:53:06.681
!MESSAGE A conflict occurred for COMMAND+SHIFT+T:
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-21 11:53:06.681
!MESSAGE A conflict occurred for ALT+COMMAND+R:
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
!SESSION 2023-05-17 10:01:09.813 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=macosx, ARCH=aarch64, WS=cocoa, NL=en_GB
Framework arguments:  -product org.eclipse.epp.package.jee.product -product org.eclipse.epp.package.jee.product -product org.eclipse.epp.package.jee.product -keyring /Users/neilurquhart/.eclipse_keyring
Command-line arguments:  -os macosx -ws cocoa -arch aarch64 -product org.eclipse.epp.package.jee.product -product org.eclipse.epp.package.jee.product -data /Users/neilurquhart/Dropbox/LB-CPC/ -product org.eclipse.epp.package.jee.product -keyring /Users/neilurquhart/.eclipse_keyring

!ENTRY org.eclipse.jface 2 0 2023-05-17 10:01:12.197
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-17 10:01:12.197
!MESSAGE A conflict occurred for COMMAND+SHIFT+T:
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(COMMAND+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-17 10:01:12.197
!MESSAGE A conflict occurred for ALT+COMMAND+R:
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
Binding(ALT+COMMAND+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,cocoa,system)
